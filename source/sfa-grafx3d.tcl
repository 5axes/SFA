# start x3dom file for non-FEM graphics
proc x3dFileStart {} {
  global brepEnts cadSystem entCount localName opt stepAP timeStamp viz writeDir writeDirType
  global x3dColorBrep x3dFile x3dFileName x3dMax x3dMin x3dStartFile x3dTitle

  if {$x3dStartFile == 0} {return}
  set x3dStartFile 0
  checkTempDir

# x3d output file name
  set x3dir [file rootname $localName]
  if {$opt(writeDirType) == 2} {set x3dir [file join $writeDir [file rootname [file tail $localName]]]}
  set x3dFileName $x3dir\-sfa.html
  set x3dFile [open $x3dFileName w]

# delete old output files
  catch {file delete -force -- $x3dFileName}
  catch {file delete -force -- "$x3dir\_x3dom.html"}
  catch {file delete -force -- "$x3dir\-x3dom.html"}

# start x3d file
  set title [file tail $localName]
  if {$stepAP != "" && [string range $stepAP 0 1] == "AP"} {append title " | $stepAP"}
  puts $x3dFile "<!DOCTYPE html>\n<html>\n<head>\n<title>$title</title>\n<base target=\"_blank\">\n<meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>"
  puts $x3dFile "<link rel='stylesheet' type='text/css' href='https://www.x3dom.org/x3dom/release/x3dom.css'/>\n<script type='text/javascript' src='https://www.x3dom.org/x3dom/release/x3dom.js'></script>\n</head>"

  set x3dTitle [file tail $localName]
  if {$stepAP != "" && [string range $stepAP 0 1] == "AP"} {append x3dTitle "&nbsp;&nbsp;&nbsp;$stepAP"}
  if {$timeStamp != ""} {
    set ts [fixTimeStamp $timeStamp]
    append x3dTitle "&nbsp;&nbsp;&nbsp;$ts"
  }
  if {$cadSystem != ""} {
    regsub -all "_" $cadSystem " " cs
    append x3dTitle "&nbsp;&nbsp;&nbsp;$cs"
  }
  puts $x3dFile "\n<body><font face=\"arial\">\n<h3>$x3dTitle</h3>"
  puts $x3dFile "\n<table>"

# messages above the x3d
  set msg ""
  if {$opt(VIZBRP)} {
    set ok 0
    foreach item $brepEnts {if {[info exists entCount($item)]} {set ok 1}}
    set x3dColorBrep [x3dBrepColor]
  }

  if {$viz(PMI)} {
    append msg "$viz(PMIMSG)  "
  } elseif {$opt(VIZPMI)} {
    if {[string first "Some Graphical PMI" $viz(PMIMSG)] == 0} {append msg "The STEP file contains only Semantic PMI and no Graphical PMI.  "}
  }
  if {$viz(TPG) && [info exist entCount(next_assembly_usage_occurrence)]} {append msg "Tessellated parts in an assembly might have the wrong position and orientation or be missing."}
  if {$msg != ""} {puts $x3dFile "<tr><td valign='top' width='85%'>[string trim $msg]</td><td></td></tr>"}

# x3d window size
  puts $x3dFile "<tr><td valign='top' width='85%'>"
  set height 900
  set width [expr {int($height*1.78)}]
  catch {
    set height [expr {int([winfo screenheight .]*0.85)}]
    set width [expr {int($height*[winfo screenwidth .]/[winfo screenheight .])}]
  }
  puts $x3dFile "\n<X3D id='x3d' showStat='false' showLog='false' x='0px' y='0px' width='$width' height='$height' style='border:1px solid black'>\n<Scene DEF='scene'>"
  puts $x3dFile "<!-- X3D generated by the NIST STEP File Analyzer and Viewer -->"

# read tessellated geometry separately because of IFCsvr limitations
  if {($viz(PMI) && [info exists entCount(tessellated_annotation_occurrence)]) || $viz(TPG)} {tessReadGeometry}
  outputMsg " Writing View to: [truncFileName [file nativename $x3dFileName]]" green

# coordinate min, max, center
  if {$x3dMax(x) != -1.e10} {
    foreach xyz {x y z} {
      set delt($xyz) [expr {$x3dMax($xyz)-$x3dMin($xyz)}]
      set xyzcen($xyz) [format "%.4f" [expr {0.5*$delt($xyz) + $x3dMin($xyz)}]]
    }
    set maxxyz $delt(x)
    if {$delt(y) > $maxxyz} {set maxxyz $delt(y)}
    if {$delt(z) > $maxxyz} {set maxxyz $delt(z)}
  }
  update idletasks
}

# -------------------------------------------------------------------------------
# finish x3d file, write tessellated edges, PMI saved view geometry, set viewpoints, add navigation and background color, and close X3DOM file
proc x3dFileEnd {} {
  global ao brepEnts brepFile brepFileName datumTargetView entCount nistModelURLs nistName nistVersion
  global numTessColor opt savedViewButtons savedViewFile savedViewFileName savedViewItems savedViewNames savedViewNone sphereDef stepAP
  global tessCoord tessEdges tessPartFile tessPartFileName viz x3dAppColor x3dApps x3dAxes x3dColorsUsed x3dCoord x3dFile
  global x3dIndex x3dMax x3dMin x3dMsg x3dShape x3dStartFile x3dTitle

# PMI is already written to file
# generate b-rep part geometry based on Open Cascade
  set viz(BRP) 0
  if {$opt(VIZBRP)} {
    set ok 0
    foreach item $brepEnts {if {[info exists entCount($item)]} {set ok 1}}
    if {$ok} {x3dBrepGeomColor}
  }

# coordinate min, max, center
  foreach idx {x y z} {
    set delt($idx) [expr {$x3dMax($idx)-$x3dMin($idx)}]
    set xyzcen($idx) [trimNum [format "%.4f" [expr {0.5*$delt($idx) + $x3dMin($idx)}]]]
  }
  set maxxyz $delt(x)
  if {$delt(z) > $maxxyz} {set maxxyz $delt(z)}
  set maxxz $maxxyz
  if {$delt(y) > $maxxyz} {set maxxyz $delt(y)}

# -------------------------------------------------------------------------------
# PMI not in a saved view
  if {[info exists savedViewNone]} {puts $x3dFile "</Group></Switch>"}

# -------------------------------------------------------------------------------
# write tessellated edges
  set viz(TED) 0
  if {[info exists tessEdges]} {
    puts $x3dFile "\n<!-- TESSELLATED EDGES -->\n<Switch whichChoice='0' id='swTED'><Group>"
    foreach cid [array names tessEdges] {
      puts $x3dFile "<Shape><Appearance><Material emissiveColor='0 0 0'></Material></Appearance>"
      puts $x3dFile " <IndexedLineSet coordIndex='[join $tessEdges($cid)]'>"
      puts $x3dFile "  <Coordinate DEF='coord$cid' point='$tessCoord($cid)'></Coordinate></IndexedLineSet></Shape>"
    }
    puts $x3dFile "</Group></Switch>"
    set viz(TED) 1
    unset tessEdges
  }

# -------------------------------------------------------------------------------
# holes
  set ok 0
  set viz(HOL) 0
  set sphereDef {}
  foreach ent [list counterbore_hole_occurrence counterdrill_hole_occurrence countersink_hole_occurrence spotface_hole_occurrence] {
    if {[info exists entCount($ent)]} {set ok 1}
  }
  if {$ok} {x3dHoles $maxxyz}

# -------------------------------------------------------------------------------
# supplemental geometry
  set viz(SMG) 0
  if {[info exists entCount(constructive_geometry_representation)]} {x3dSuppGeom $maxxyz}

# -------------------------------------------------------------------------------
# datum targets
  set viz(DTR) 0
  if {[info exists datumTargetView]} {
    x3dDatumTarget $maxxyz
  } elseif {[info exists entCount(placed_datum_target_feature)] || [info exists entCount(datum_target)]} {
    set msg " Datum targets cannot be shown without "
    if {$opt(XLSCSV) != "Excel"} {
      append msg "generating a spreadsheet"
    } elseif {!$opt(PMISEM)} {
      append msg "selecting Analyze Semantic PMI"
    }
    append msg ".  See Help > View > Datum Targets"
    outputMsg $msg red
  }

# -------------------------------------------------------------------------------
# write any PMI saved view geometry for multiple saved views
  set savedViewButtons {}
  if {[info exists savedViewNames]} {
    if {[llength $savedViewNames] > 0} {
      for {set i 0} {$i < [llength $savedViewNames]} {incr i} {
        set svn [lindex $savedViewNames $i]
        set svnfn "View$i"
        catch {close $savedViewFile($svnfn)}
        if {[info exists savedViewFileName($svnfn)]} {
          if {[file size $savedViewFileName($svnfn)] > 0} {
            set svMap($svn) $svn
            set svWrite 1

# check if same saved view graphics already written
            if {[info exists savedViewItems($svn)]} {
              for {set j 0} {$j < $i} {incr j} {
                set svn1 [lindex $savedViewNames $j]
                if {[info exists savedViewItems($svn1)]} {
                  if {$savedViewItems($svn) == $savedViewItems($svn1)} {
                    set svMap($svn) $svn1
                    set svWrite 0
                    break
                  }
                }
              }
            }

            set svn2 $svn
            if {$svn2 == ""} {
              set svn2 "Missing name"
              set svMap($svn2) $svn2
            }
            lappend savedViewButtons $svn2

            puts $x3dFile "\n<!-- SAVED VIEW$i $svn2 -->"
            puts $x3dFile "<Switch whichChoice='0' id='sw$svnfn'><Group>"
            if {$svWrite} {

# get saved view graphics from file
              set lastTransform ""
              set f [open $savedViewFileName($svnfn) r]
              while {[gets $f line] >= 0} {

# check for similar transforms
                if {[string first "<Transform" $line] == -1 && [string first "</Transform>" $line] == -1} {
                  puts $x3dFile $line
                } elseif {[string first "<Transform" $line] == 0} {
                  if {$line != $lastTransform} {
                    if {$lastTransform != ""} {puts $x3dFile "</Transform>"}
                    puts $x3dFile $line
                    set lastTransform $line
                  }
                }
              }
              if {$lastTransform != ""} {puts $x3dFile "</Transform>"}

              close $f
              catch {unset savedViewFile($svnfn)}
            } else {
              puts $x3dFile "<!-- SAME AS $svMap($svn) -->"
              errorMsg " Two or more Saved Views have the exact same PMI." red
            }
            puts $x3dFile "</Group></Switch>"
          } else {
            catch {close $savedViewFile($svnfn)}
          }
        }
        catch {file delete -force -- $savedViewFileName($svnfn)}
      }
    }
  }

# -------------------------------------------------------------------------------
# coordinate axes, if not already written
  if {$x3dAxes} {
    set asize [trimNum [expr {$maxxyz*0.05}]]
    x3dCoordAxes $asize
  }

# -------------------------------------------------------------------------------
# write tessellated part
  if {[info exists tessPartFile]} {
    puts $x3dFile "\n<!-- TESSELLATED PART GEOMETRY -->\n<Switch whichChoice='0' id='swTPG'><Group>"
    catch {close $tessPartFile}

    set lastTransform ""
    set f [open $tessPartFileName r]

# first check for similar transforms, write to tmp file
    while {[gets $f line] >= 0} {
      if {[string first "<Transform" $line] == -1 && [string first "</Transform>" $line] == -1} {
        puts $x3dFile $line
      } elseif {[string first "<Transform" $line] == 0} {
        if {$line != $lastTransform} {
          if {$lastTransform != ""} {puts $x3dFile "</Transform>"}
          puts $x3dFile $line
          set lastTransform $line
        }
      }
    }
    close $f

    if {$lastTransform != ""} {puts $x3dFile "</Transform>"}
    puts $x3dFile "</Group></Switch>"
    catch {file delete -force -- $tessPartFileName}
    unset tessPartFile
    unset tessPartFileName
  }

# -------------------------------------------------------------------------------
# add b-rep part geometry from temp file
  if {$viz(BRP)} {
    if {[info exists brepFileName]} {
      if {[file exists $brepFileName]} {
        close $brepFile
        if {[file size $brepFileName] > 0} {
          set brepFile [open $brepFileName r]
          while {[gets $brepFile line] >= 0} {puts $x3dFile $line}
          close $brepFile
          if {!$opt(DEBUGX3D)} {catch {file delete -force -- $brepFileName}}
        }
      }
    }
  }

# -------------------------------------------------------------------------------
# default viewpoint
  puts $x3dFile "\n<!-- VIEWPOINTS -->"
  set cor "centerOfRotation='$xyzcen(x) $xyzcen(y) $xyzcen(z)'"
  set fov [trimNum [expr {$delt(x)*0.5 + $delt(z)*0.5}]]
  set psy [trimNum [expr {$x3dMin(y) - 1.4*$maxxz}]]

  puts $x3dFile "<Viewpoint id='Front' position='$xyzcen(x) $psy $xyzcen(z)' orientation='1 0 0 1.5708' $cor></Viewpoint>"
  puts $x3dFile "<OrthoViewpoint id='Ortho' position='$xyzcen(x) $psy $xyzcen(z)' orientation='1 0 0 1.5708' $cor fieldOfView='\[-$fov,-$fov,$fov,$fov\]'></OrthoViewpoint>"

# navigation, background color
  set bgc "1 1 1"
  if {[info exists x3dColorsUsed]} {
    set x3dColorsUsed [lrmdups $x3dColorsUsed]

# if yellow or white is one of the colors used, set background color to gray
    foreach color {"1 1 0" "1 1 1" "1. 1. 1."} {
      if {[lsearch $x3dColorsUsed $color] != -1} {
        set bgc ".8 .8 .8"
        break
      }
    }
  }

  puts $x3dFile "\n<!-- BACKGROUND -->"
  puts $x3dFile "<Background id='BG' skyColor='$bgc'></Background>"
  puts $x3dFile "<NavigationInfo type='\"EXAMINE\" \"ANY\"'></NavigationInfo>"
  regsub -all "&nbsp;" $x3dTitle " " title
  puts $x3dFile "<WorldInfo title='$title' info='\"Generated by the NIST STEP File Analyzer and Viewer [getVersion]\"'></WorldInfo>"
  puts $x3dFile "</Scene></X3D>"

# credits
  set ver "NIST "
  set url "https://www.nist.gov/services-resources/software/step-file-analyzer-and-viewer"
  if {!$nistVersion} {
    set ver ""
    set url "https://github.com/usnistgov/SFA"
  }

  set str "\n<p>Generated by the <a href=\"$url\">$ver\STEP File Analyzer and Viewer (v[getVersion])</a>"
  if {$viz(BRP) && [string first "AP209" $stepAP] == -1} {
    append str ".&nbsp;&nbsp;Other <a href=\"https://www.cax-if.org/step_viewers.php\">STEP file viewers</a> are available"
  }
  append str ".&nbsp;&nbsp;<a href=\"https://www.nist.gov/disclaimer\">NIST Disclaimer</a>&nbsp;&nbsp;[clock format [clock seconds] -format "%d %b %G %H:%M"]"
  puts $x3dFile $str

# start right column
  puts $x3dFile "</td>\n\n<!-- RIGHT COLUMN BUTTONS -->\n<td valign='top'>"

# -------------------------------------------------------------------------------
# for NIST model - link to drawing
  if {$nistName != ""} {
    foreach item $nistModelURLs {
      if {[string first $nistName $item] == 0} {puts $x3dFile "<a href=\"https://s3.amazonaws.com/nist-el/mfg_digitalthread/$item\">NIST Test Case Drawing</a><p>"}
    }
  }

# part geometry checkbox
  if {$viz(BRP)} {
    puts $x3dFile "\n<!-- Part geometry checkbox -->\n<input type='checkbox' checked onclick='togBRP(this.value)'/>Part Geometry"

# part color checkboxes
    if {[info exists x3dApps]} {
      if {[llength $x3dApps] > 1} {
        set star 0
        puts $x3dFile "\n<p><!-- Part color checkboxes -->\nPart Colors "
        foreach n [lsort -integer $x3dApps] {
          set str $x3dAppColor($n)
          if {[string first $n $x3dAppColor($n)] == -1} {append str $n}
          if {[string first "*" $str] != -1} {set star 1}
          puts $x3dFile "<nobr><input type='checkbox' checked onclick='togColor$n\(this.value)'/>$str </nobr>"
        }
        if {$star} {puts $x3dFile "<nobr>(* multiple part colors)</nobr>"}
      }
    }
    puts $x3dFile "<p>"
  }

# tessellated part geometry checkbox
  if {$viz(TPG)} {
    puts $x3dFile "\n<!-- Tessellated part geometry checkbox -->\n<input type='checkbox' checked onclick='togTPG(this.value)'/>Tessellated Part Geometry"
    if {$viz(TED)} {puts $x3dFile "<!-- Tessellated edges checkbox -->\n<br><input type='checkbox' checked onclick='togTED(this.value)'/>Lines (Tessellated Edges)"}
    puts $x3dFile "<p>"
  }

# supplemental geometry checkbox
  if {$viz(SMG)} {
    puts $x3dFile "\n<!-- Supplemental geometry checkbox -->\n<input type='checkbox' checked onclick='togSMG(this.value)'/>Supplemental Geometry"
    if {$viz(DTR)} {
      puts $x3dFile "<br>"
    } else {
      puts $x3dFile "<p>"
    }
  }

# datum targets checkbox
  if {$viz(DTR)} {
    puts $x3dFile "\n<!-- Datum targets checkbox -->\n<input type='checkbox' checked onclick='togDTR(this.value)'/>Datum Targets<p>"
  }

# holes checkbox
  if {$viz(HOL)} {
    puts $x3dFile "\n<!-- Holes checkbox -->\n<input type='checkbox' checked onclick='togHole(this.value)'/>Holes<p>"
  }

# for PMI annotations - checkboxes for toggling saved view graphics
  if {$viz(PMI) && [llength $savedViewButtons] > 0} {
    puts $x3dFile "\n<!-- Saved view checkboxes -->\nSaved View Graphical PMI"
    set ok 1
    foreach svn $savedViewButtons {
      puts $x3dFile "<br><input type='checkbox' checked onclick='togView[lsearch $savedViewNames $svn]\(this.value)'/>$svn"
      if {[string first "MBD" [string toupper $svn]] == -1 && $nistName != ""} {set ok 0}
    }
  }

# PMI not in a saved view
  if {[info exists savedViewNone]} {
    if {$viz(PMI) && [llength $savedViewButtons] > 0} {
      set str "Not in a Saved View"
      set pbr "br"
    } else {
      set str "Graphical PMI"
      set pbr "p"
    }
    puts $x3dFile "\n<!-- PMI not in a saved view checkbox -->\n<$pbr><input type='checkbox' checked onclick='togPMI(this.value)'/>$str\n<p>"
  }

# FEM checkboxes
  if {$viz(FEA)} {feaButtons 1}

# extra text messages
  if {[info exists x3dMsg]} {
    if {[llength $x3dMsg] > 0} {
      puts $x3dFile "\n<!-- Messages -->"
      puts $x3dFile "<ul style=\"padding-left:20px\">"
      foreach item $x3dMsg {puts $x3dFile "<li>$item"}
      puts $x3dFile "</ul>"
      unset x3dMsg
    }
  }

# axes checkbox
  puts $x3dFile "\n<!-- Axes checkbox -->\n<p><hr><p><input type='checkbox' checked onclick='togAxes(this.value)'/>Origin<p>"

# background color radio buttons
  puts $x3dFile "\n<!-- Background radio button -->\nBackground Color<br>"
  set check1 "checked"
  set check2 ""
  if {$bgc == ".8 .8 .8"} {
    set check2 "checked"
    set check1 ""
  }
  puts $x3dFile "<input type='radio' name='bgcolor' value='1 1 1' $check1 onclick='BGcolor(this.value)'/>White<br>"
  puts $x3dFile "<input type='radio' name='bgcolor' value='.8 .8 .8' $check2 onclick='BGcolor(this.value)'/>Gray<br>"
  puts $x3dFile "<input type='radio' name='bgcolor' value='0 0 0' onclick='BGcolor(this.value)'/>Black"

# transparency slider
  set max 0
  set transFunc 0
  if {$viz(FEA) && ([info exists entCount(surface_3d_element_representation)] || [info exists entCount(volume_3d_element_representation)])} {
    set max 0.9
  } elseif {$viz(BRP)} {
    set max 0.9
  } elseif {$viz(TPG)} {
    set max 0.9
    if {$opt(VIZTPGMSH)} {set max 1}
  }
  if {$max > 0} {
    puts $x3dFile "\n<!-- Transparency slider -->\n<p>Transparency<br>(approximate)<br>"
    puts $x3dFile "<input style='width:80px' type='range' min='0' max='$max' step='0.1' value='0' onchange='matTrans(this.value)'/>"
    set transFunc 1
  }

# mouse message
  puts $x3dFile "\n<p>Key 'a' to view all, 'r' to restore, Page Up for orthographic.  <a href=\"https://www.x3dom.org/documentation/interaction/\">Use the mouse</a> in 'Examine Mode' to rotate, pan, zoom."
  puts $x3dFile "</td></tr></table>"

# -------------------------------------------------------------------------------
# function for BRP, colors
  if {$viz(BRP)} {
    x3dSwitchScript BRP
    if {[info exists x3dApps]} {
      if {[llength $x3dApps] > 1} {
        foreach n [lsort -integer $x3dApps] {x3dSwitchScript Color$n}
      }
    }
  }

# switch functions for fem
  if {$viz(FEA)} {
    x3dSwitchScript Nodes
    if {[info exists entCount(surface_3d_element_representation)] || \
        [info exists entCount(volume_3d_element_representation)]}  {x3dSwitchScript Mesh}
    if {[info exists entCount(curve_3d_element_representation)]}   {x3dSwitchScript 1DElements}
    if {[info exists entCount(surface_3d_element_representation)]} {x3dSwitchScript 2DElements}
    if {[info exists entCount(volume_3d_element_representation)]}  {x3dSwitchScript 3DElements}
  }

# function for TPG
  if {$viz(TPG)} {
    if {[string first "occurrence" $ao] == -1} {
      x3dSwitchScript TPG
      if {$viz(TED)} {x3dSwitchScript TED}
    }
  }

# function for SMG
  if {$viz(SMG)} {x3dSwitchScript SMG}

# function for DTR
  if {$viz(DTR)} {x3dSwitchScript DTR}

# function for holes
  if {$viz(HOL)} {x3dSwitchScript Hole}

# functions for PMI
  if {$viz(PMI)} {
    if {[llength $savedViewButtons] > 0} {
      puts $x3dFile " "
      foreach svn $savedViewButtons {x3dSwitchScript View[lsearch $savedViewNames $svn] $svMap($svn)}
    }
  }
  if {[info exists savedViewNone]} {x3dSwitchScript PMI}
  catch {unset savedViewNone}

# functions for FEA buttons
  if {$viz(FEA)} {feaButtons 2}

# background function
  puts $x3dFile "\n<!-- Background function -->\n<script>function BGcolor(color){document.getElementById('BG').setAttribute('skyColor', color);}</script>"

# axes function
  x3dSwitchScript Axes

# transparency function
  set numTessColor 0
  if {$viz(TPG)} {set numTessColor [tessCountColors]}
  if {$transFunc} {
    puts $x3dFile "\n<!-- Transparency function -->\n<script>function matTrans(trans){"

# part geometry
    if {$viz(BRP)} {
      if {[info exists x3dApps]} {foreach n [lsort -integer $x3dApps] {puts $x3dFile " document.getElementById('mat$n').setAttribute('transparency', trans);"}}
    }

# tessellated geometry
    for {set i 1} {$i <= $numTessColor} {incr i} {puts $x3dFile " document.getElementById('matTess$i').setAttribute('transparency', trans);"}

    if {$viz(FEA)} {
      if {[info exists entCount(surface_3d_element_representation)]} {
        puts $x3dFile " document.getElementById('mat2Dfem').setAttribute('transparency', trans);"
      }
      if {[info exists entCount(volume_3d_element_representation)]}  {
        puts $x3dFile " document.getElementById('mat3Dfem').setAttribute('transparency', trans);"
        puts $x3dFile " if (trans > 0) {document.getElementById('faces').setAttribute('solid', true);} else {document.getElementById('faces').setAttribute('solid', false);}"
      }
    }
    puts $x3dFile "}\n</script>"
  }

  puts $x3dFile "</font></body></html>"
  close $x3dFile
  update idletasks

# unset variables
  foreach var [list x3dCoord x3dFile x3dIndex x3dMax x3dMin x3dShape x3dStartFile] {catch {unset $var}}
}

# -------------------------------------------------------------------------------
# B-rep part geometry
proc x3dBrepGeomColor {} {
  global brepFile brepFileName buttons defaultColor localName mytemp opt viz wdir x3dAppColor x3dApps x3dMax x3dMin x3dMsg

# copy stp2x3d-color.* files to temp directory, zip contains DLLs for stp2x3d-color.exe, exe is stp2x3d-color.exe
  if {[catch {
    if {$opt(DEBUGX3D)} {getTiming}
    foreach ext {zip exe} {
      set internal [file join $wdir exe stp2x3d-color.$ext]
      set stp2x3d [file join $mytemp stp2x3d-color.$ext]
      if {[file exists $internal]} {
        set copy 0
        if {![file exists $stp2x3d]} {
          set copy 1
        } elseif {[file mtime $internal] > [file mtime $stp2x3d]} {
          set copy 1
        }
        if {$copy} {if {$opt(DEBUGX3D)} {outputMsg "copy $stp2x3d"}; file copy -force -- $internal $stp2x3d}
      }
    }

# extract DLLs from zip file
    set stp2x3dz [file join $mytemp stp2x3d-color.zip]
    if {[file exists $stp2x3dz]} {
      vfs::zip::Mount $stp2x3dz stp2x3d-color
      foreach file [glob -nocomplain stp2x3d-color/*] {
        set fn [file join $mytemp [file tail $file]]
        set copy 0
        if {![file exists $fn]} {
          set copy 1
        } elseif {[file mtime $file] > [file mtime $fn]} {
          set copy 1
        }
        if {$copy} {if {$opt(DEBUGX3D)} {outputMsg "copy $file"}; file copy -force -- $file $fn}
      }
      if {$opt(DEBUGX3D)} {getTiming "copy and extract"}
    }

# generate x3d from b-rep geometry with stp2x3d-color
    set stp2x3d [file join $mytemp stp2x3d-color.exe]
    if {[file exists $stp2x3d]} {

# output .x3d file name
      set stpx3dFileName [string range $localName 0 [string last "." $localName]]
      append stpx3dFileName "x3d"
      catch {file delete -force -- $stpx3dFileName}

# output dir for stp2x3d-color, delete if it exists
      set ftail [file tail [file rootname $localName]]
      set msg " Processing STEP part geometry"
      if {[info exists buttons]} {append msg ".  Please wait, this might take several minutes for large STEP files."}
      outputMsg $msg green

# run stp2x3d-color.exe
      if {$opt(DEBUGX3D)} {getTiming}
      if {$opt(x3dQuality) != 7 && $opt(x3dQuality) != 9} {set opt(x3dQuality) 7}
      catch {exec $stp2x3d [file nativename $localName] --quality $opt(x3dQuality)} errs
      if {$opt(DEBUGX3D)} {getTiming stp2x3d; outputMsg "Output from stp2x3d-color.exe"; outputMsg $errs}

# done processing
      if {[string first "STEP to X3D completed!" $errs] != -1} {
        if {[file exists $stpx3dFileName]} {
          if {[file size $stpx3dFileName] > 0} {
            set apps {}
            set napp -1

# check for conversion units, mm > inch
            set sc [x3dBrepUnits]

# get min and max, report bounding box
            set bbox ""
            foreach line [split $errs "\n"] {
              if {[string first "No color will be supported." $line] != -1} {outputMsg "  Using [lindex $defaultColor 1] for the part color" red}

              set sline [split [string trim $line] " "]
              if {[string first "MinXYZ" $line] != -1} {
                append bbox "   Min XYZ:"
                foreach id1 {1 2 3} id2 {x y z} {
                  set x3dMin($id2) [expr {$sc*[lindex $sline $id1]}]
                  append bbox " [trimNum [lindex $sline $id1]]"
                }
              }
              if {[string first "MaxXYZ" $line] != -1} {
                append bbox "   Max XYZ:"
                foreach id1 {1 2 3} id2 {x y z} {
                  set x3dMax($id2) [expr {$sc*[lindex $sline $id1]}]
                  append bbox " [trimNum [lindex $sline $id1]]"
                }
              }
            }
            if {$bbox != ""} {outputMsg "  Bounding Box$bbox"}

# open temp file
            set brepFileName [file join $mytemp brep.txt]
            set brepFile [open $brepFileName w]

# integrate x3d from stp2x3d-color with existing x3dom file
            set str "\n<!-- PART GEOMETRY -->\n<Switch whichChoice='0' id='swBRP'>"
            if {$sc != 1} {
              append str "<Transform scale='$sc $sc $sc'>"
            } else {
              append str "<Group>"
            }
            puts $brepFile $str
            set stpx3dFile [open $stpx3dFileName r]
            set write 0

# process all lines in file
            outputMsg " Processing X3D output" green; update
            while {[gets $stpx3dFile line] >= 0} {
              set appLine -1
              if {[string first "<Shape" $line] != -1} {
                set write 1
                gets $stpx3dFile line
                set appLine [string first "<Appearance" $line]
              } elseif {[string first "</Scene>" $line] != -1} {
                set write 0
              }

# appearance color
              if {$write} {
                if {$appLine != -1} {
                  set diffuse 0
                  if {[string first "diffuseColor" $line] != -1} {set diffuse 1}

# single diffuseColor
                  if {$diffuse} {
                    set rgb [string range $line $appLine+36 end]
                    set rgb [string range $rgb 0 [string first "'" $rgb]-1]
                    set iapp [lsearch $apps $rgb]
                    if {$iapp == -1} {lappend apps $rgb}

# multiple colors, read three lines to get to Color node
                  } else {
                    foreach i {0 1 2} {gets $stpx3dFile nline($i)}
                    set napp1 [expr {$napp+1}]
                    set rgb "$napp1\*"
                    set iapp [lsearch $apps $nline(2)]
                    if {$iapp == -1} {
                      lappend apps $nline(2)
                      set nline(2) "[string range $nline(2) 0 7] DEF='color$napp1' [string range $nline(2) 9 end]"
                    } else {
                      set nline(2) " <Color USE='color$iapp'></Color>"
                    }
                  }

# each color written to different file
                  if {$iapp == -1} {
                    incr napp
                    set f [file join $mytemp app$napp.txt]
                    set appFiles($napp) [open $f w]
                    set appFile $appFiles($napp)
                    puts $appFile "<Shape>\n <Appearance DEF='app$napp'><Material id='mat$napp' [string range $line $appLine+22 end]"
                    set x3dAppColor($napp) [x3dColorName $rgb]
                    if {$opt(DEBUGX3D)} {outputMsg "color $napp  $rgb" red}

# color file already opened
                  } else {
                    set appFile $appFiles($iapp)
                    puts $appFile "<Shape>\n <Appearance USE='app$iapp'></Appearance>"
                  }

# write three extra lines
                  if {!$diffuse} {foreach i {0 1 2} {puts $appFile $nline($i)}}

# other lines
                } else {
                  puts $appFile $line
                }
              }
            }

# add appN.txt files to b-rep file
            catch {unset x3dApps}
            set len [llength [array names appFiles]]
            foreach napp [lsort -integer [array names appFiles]] {
              lappend x3dApps $napp
              close $appFiles($napp)
              set appFile [open [file join $mytemp "app$napp.txt"] r]
              if {$len > 1} {puts $brepFile "\n<!-- COLOR $napp -->\n<Switch whichChoice='0' id='swColor$napp'><Group>"}
              while {[gets $appFile line] >= 0} {puts $brepFile $line}
              if {$len > 1} {puts $brepFile "</Group></Switch>"}
              close $appFile
            }

# end the brep file
            if {$sc == 1} {
              puts $brepFile "</Group></Switch>"
            } else {
              puts $brepFile "</Transform></Switch>"
            }

            set viz(BRP) 1
            close $stpx3dFile
          }

# no X3D output
        } else {
          errorMsg " ERROR: Cannot find the part geometry (X3D file) output from stp2x3d-color.exe"
        }

# delete X3D file
        if {!$opt(DEBUGX3D)} {
          catch {file delete -force -- $stpx3dFileName}

# keep for debugging
        } else {
          set newnam "[file rootname $localName].x3d"
          if {$stpx3dFileName != $newnam} {
            file copy -force -- $stpx3dFileName $newnam
            catch {file delete -force -- $stpx3dFileName}
          }
        }

# errors running stp2x3d
      } else {
        outputMsg " stp2x3d-color.exe ERRORS\n$errs" red
        errorMsg " ERROR generating X3D from the STEP part geometry\n  Try another STEP file viewer.  See Websites > STEP File Viewers\n  Use F8 to run the Syntax Checker to check for STEP file errors.  See Help > Syntax Checker"
        outputMsg " "
        lappend x3dMsg "<b>Error generating STEP part geometry</b>"
      }
    } else {
      errorMsg " ERROR: The program (stp2x3d-color.exe) to convert STEP part geometry to X3D was not found in $mytemp"
    }
  } emsg]} {
    errorMsg " ERROR adding Part Geometry: $emsg"
  }
}

# -------------------------------------------------------------------------------
proc x3dBrepColor {} {
  global opt syntaxErr x3dColorBrepAdjusted x3dColorsUsed
  global objDesign

  set debug 0
  set x3dColorBrep ""
  set x3dColorAll 0
  foreach item {manifold_solid_brep shell_based_surface_model advanced_face} {set colors($item) {}}

# get styled_item
  catch {
    ::tcom::foreach e0 [$objDesign FindObjects [string trim styled_item]] {
      if {$debug} {errorMsg "[$e0 Type] [$e0 P21ID]" green}

# styled_item.styles
      set styledItem [$e0 Type]
      if {$styledItem == "styled_item" || $styledItem == "over_riding_styled_item"} {
        if {[[[$e0 Attributes] Item [expr 3]] Value] != ""} {
          set item [[[[$e0 Attributes] Item [expr 3]] Value] Type]
        } elseif {$styledItem == "styled_item"} {
          set msg "Missing required styled_item 'item' attribute or it references the wrong type of entity."
          if {$opt(XLSCSV) == "None"} {append msg "  Generate a Spreadsheet to see the problem with styled_item."}
          errorMsg $msg
          lappend syntaxErr(styled_item) [list [$e0 P21ID] item $msg]
          set item ""
        }

# presentation_style.styles
        if {$item == "manifold_solid_brep" || $item == "shell_based_surface_model" || $item == "advanced_face"} {
          set a1 [[$e0 Attributes] Item [expr 2]]
          ::tcom::foreach e2 [$a1 Value] {
            set a2 [[$e2 Attributes] Item [expr 1]]
            set e3 [$a2 Value]
            set a3 [[$e3 Attributes] Item [expr 2]]

# surface side style
            set e4 [$a3 Value]
            set a4s [[$e4 Attributes] Item [expr 2]]

# surface style fill area
            foreach e5 [$a4s Value] {
              if {[$e5 Type] == "surface_style_fill_area"} {
                set a5 [[$e5 Attributes] Item [expr 1]]

# fill area style
                set e6 [$a5 Value]
                set a6 [[$e6 Attributes] Item [expr 2]]

# fill area style colour
                set e7 [$a6 Value]
                set a7 [[$e7 Attributes] Item [expr 2]]

# color
                set e8 [$a7 Value]
                if {[$e8 Type] == "colour_rgb"} {
                  set x3dColorBrep ""
                  set j 0
                  ::tcom::foreach a8 [$e8 Attributes] {
                    if {$j > 0} {append x3dColorBrep "[trimNum [$a8 Value] 3] "}
                    incr j
                  }
                  set x3dColorBrep [string trim $x3dColorBrep]
                  lappend colors($item) $x3dColorBrep
                } elseif {[$e8 Type] == "draughting_pre_defined_colour"} {
                  set x3dColorBrep [x3dPreDefinedColor [[[$e8 Attributes] Item [expr 1]] Value]]
                  lappend colors($item) $x3dColorBrep
                } else {
                  errorMsg "  Part geometry color type '[$e8 Type]' is not supported."
                }
                if {$debug} {errorMsg "$x3dColorBrep  $item" red}
              }
            }
          }
        }
      }
    }
  }

# all colors
  set colorsAll [lrmdups [concat $colors(manifold_solid_brep) $colors(shell_based_surface_model) $colors(advanced_face)]]
  set x3dColorAll [llength $colorsAll]

  if {$x3dColorAll > 1} {
    set x3dColorBrep ""

# adjust color for comparison to PMI color
  } else {
    lappend x3dColorsUsed $x3dColorBrep
    set x3dColorBrepAdjusted ""
    foreach val $x3dColorBrep {
      set nval $val
      if {$val < 0.3} {set nval 0}
      if {$val > 0.7} {set nval 1}
      append x3dColorBrepAdjusted "$nval "
    }
    set x3dColorBrepAdjusted [string trim $x3dColorBrepAdjusted]
  }

  if {$debug} {outputMsg $x3dColorBrep blue}
  return $x3dColorBrep
}

# -------------------------------------------------------------------------------
# check for conversion units, mm > inch
proc x3dBrepUnits {} {
  global objDesign

  set sc 1
  set a2 ""
  ::tcom::foreach e0 [$objDesign FindObjects [string trim advanced_brep_shape_representation]] {
    set e1 [[[$e0 Attributes] Item [expr 3]] Value]
    set a2 [[$e1 Attributes] Item [expr 5]]
    if {$a2 == ""} {set a2 [[$e1 Attributes] Item [expr 4]]}
  }
  if {$a2 == "" && ![info exists entCount(advanced_brep_shape_representation)]} {
    ::tcom::foreach e0 [$objDesign FindObjects [string trim geometric_representation_context_and_global_uncertainty_assigned_context_and_global_unit_assigned_context]] {
      set a2 [[$e0 Attributes] Item [expr 5]]
    }
  }
  if {$a2 != ""} {
    foreach e3 [$a2 Value] {
      if {[$e3 Type] == "conversion_based_unit_and_length_unit"} {
        set e4 [[[$e3 Attributes] Item [expr 3]] Value]
        set cf [[[$e4 Attributes] Item [expr 1]] Value]
        set sc [trimNum [expr {1./$cf}] 5]
      }
    }
  }
  return $sc
}

# -------------------------------------------------------------------------------
# write tessellated geometry for annotations and parts
proc x3dTessGeom {objID objEntity1 ent1} {
  global ao defaultColor draftModelCameras entCount nshape opt recPracNames savedViewFile savedViewNames savedViewNone shapeRepName shellSuppGeom spaces srNames
  global tessCoord tessCoordID tessIndex tessIndexCoord tessPartFile tessPlacement tessRepo tessSuppGeomFile
  global x3dColor x3dColorFile x3dColors x3dColorsUsed x3dCoord x3dFile x3dIndex x3dMsg

  set x3dIndex $tessIndex($objID)
  set x3dCoord $tessCoord($tessIndexCoord($objID))

  if {$x3dColor == ""} {
    set x3dColor "0 0 0"
    if {[string first "annotation" [$objEntity1 Type]] != -1} {
      errorMsg "Syntax Error: Missing PMI Presentation color (using black).$spaces\($recPracNames(pmi242), Sec. 8.4, Figure 75)"
    }
  }
  set x3dIndexType "line"
  set solid ""
  set emit "emissiveColor='$x3dColor'"
  set spec ""
  set x3dSolid 0

# faces
  if {[string first "face" $ent1] != -1} {
    set x3dIndexType "face"
    set solid "solid='false'"

# tessellated part geometry
    if {$ao == "tessellated_solid" || $ao == "tessellated_shell"} {
      set tsID [$objEntity1 P21ID]
      set tessRepo 0
      set x3dSolid 1

# set default color
      set x3dColor [lindex $defaultColor 0]
      tessSetColor $objEntity1 $tsID
      set spec "specularColor='[vectrim [vecmult $x3dColor 0.2]]'"
      set emit ""

# set placement for tessellated part geometry in assemblies (axis and ref_direction)
      if {[info exists entCount(item_defined_transformation)]} {tessSetPlacement $objEntity1 $tsID}
    }
  }

# write transform based on placement
  catch {unset endTransform}
  set nplace 0
  if {[info exists tessRepo]} {
    if {$tessRepo && [info exists tessPlacement(origin)]} {set nplace [llength $tessPlacement(origin)]}
  }
  if {$nplace == 0} {set nplace 1}

# file list where to write geometry
  set nosv 1
  set flist $x3dFile
  if {$ao == "tessellated_solid" || $ao == "tessellated_shell"} {
    set flist $tessPartFile
    if {$ao == "tessellated_shell" && [info exists shellSuppGeom]} {if {$shellSuppGeom} {set flist $tessSuppGeomFile}}
    set nosv 0
  }

# multiple saved views, write PMI to individual files, collected in x3dViewpoint below
  if {[info exists draftModelCameras] && $ao == "tessellated_annotation_occurrence"} {
    set savedViewName [getSavedViewName $objEntity1]
    if {[llength $savedViewName] > 0} {
      set flist {}
      foreach svn $savedViewName {
        set svn1 "View[lsearch $savedViewNames $svn]"
        if {[info exists savedViewFile($svn1)]} {lappend flist $savedViewFile($svn1)}
      }
      set nosv 0
    }
  }

# PMI not in a saved view
  if {$nosv} {
    incr savedViewNone
    if {$savedViewNone == 1} {puts $x3dFile "\n<!-- PMI not in a saved view -->\n<Switch whichChoice='0' id='swPMI'><Group>"}
  }

# loop over list of files from above
  foreach f $flist {

# multiple saved view color
    if {[info exists savedViewName]} {
      if {$opt(gpmiColor) == 3 && [llength $savedViewNames] > 1} {
        if {![info exists x3dColorFile($f)]} {set x3dColorFile($f) [x3dSetColor $opt(gpmiColor) 1]}
        set x3dColor $x3dColorFile($f)
        set emit "emissiveColor='$x3dColor'"
      }
    }

# loop over placements, if any
    for {set np 0} {$np < $nplace} {incr np} {
      set srName ""
      if {![info exists shapeRepName]} {
        set shapeRepName $x3dIndexType
        if {[info exists tsID]} {set srName "[string toupper $ao] $tsID"}
      } elseif {$shapeRepName != "line" && $shapeRepName != "face"} {
        set srName $shapeRepName
      }
      if {$srName != ""} {
        incr srNames($srName)
        if {$srNames($srName) == 1} {puts $f "\n<!-- $srName -->"}
      }

# translation and rotation (sometimes PMI and usually assemblies)
      if {$tessRepo && [info exists tessPlacement(origin)]} {
        set transform [x3dTransform [lindex $tessPlacement(origin) $np] [lindex $tessPlacement(axis) $np] [lindex $tessPlacement(refdir) $np] "tessellated geometry"]
        puts $f $transform
        set endTransform "</Transform>"
      }

# write tessellated face or line
      if {$np == 0} {
        set defstr ""
        if {$nplace > 1} {set defstr " DEF='$shapeRepName$objID'"}

        if {$emit == ""} {
          set matID ""
          set colorID [lsearch $x3dColors $x3dColor]
          if {$colorID == -1} {
            lappend x3dColors $x3dColor
            puts $f "<Shape$defstr><Appearance DEF='app[llength $x3dColors]'><Material id='matTess[llength $x3dColors]' diffuseColor='$x3dColor' $spec></Material></Appearance>"
          } else {
            puts $f "<Shape$defstr><Appearance USE='app[incr colorID]'></Appearance>"
          }
        } else {
          puts $f "<Shape$defstr><Appearance><Material diffuseColor='$x3dColor' $emit></Material></Appearance>"
        }
        lappend x3dColorsUsed $x3dColor

        set indexedSet "<Indexed[string totitle $x3dIndexType]\Set $solid coordIndex='[string trim $x3dIndex]'>"

        if {[lsearch $tessCoordID $tessIndexCoord($objID)] == -1} {
          lappend tessCoordID $tessIndexCoord($objID)
          puts $f " $indexedSet\n  <Coordinate DEF='coord$tessIndexCoord($objID)' point='[string trim $x3dCoord]'></Coordinate></Indexed[string totitle $x3dIndexType]\Set></Shape>"
        } else {
          puts $f " $indexedSet<Coordinate USE='coord$tessIndexCoord($objID)'></Coordinate></Indexed[string totitle $x3dIndexType]\Set></Shape>"
        }

# reuse shape
      } else {
        puts $f "<Shape USE='$shapeRepName$objID'></Shape>"
      }

# for tessellated part geometry only, write mesh based on faces
      if {$opt(VIZTPGMSH) || ($ao == "tessellated_shell" && [info exists entCount(tessellated_solid)])} {
        if {$x3dIndexType == "face" && ($ao == "tessellated_solid" || $ao == "tessellated_shell")} {
          if {$np == 0} {
            set x3dMesh ""

# write individual edges
            set edges {}
            for {set i 0} {$i < [llength $x3dIndex]} {incr i 4} {
              lappend edges [lsort "[lindex $x3dIndex $i] [lindex $x3dIndex $i+1]"]
              lappend edges [lsort "[lindex $x3dIndex $i+1] [lindex $x3dIndex $i+2]"]
              lappend edges [lsort "[lindex $x3dIndex $i] [lindex $x3dIndex $i+2]"]
            }

# try to combine some edges and write mesh
            set edges [lsort [lrmdups $edges]]
            for {set i 0} {$i < [llength $edges]} {incr i} {
              set edge [lindex $edges $i]
              set nedge [lindex $edges $i+1]
              if {[lindex $edge 1] == [lindex $nedge 0]} {
                set edge [lappend edge [lindex $nedge 1]]
                incr i
              } elseif {[lindex $edge 0] == [lindex $nedge 0]} {
                set edge [concat [lindex $nedge 1] $edge]
                incr i
              }
              append x3dMesh "$edge -1 "
            }

# write mesh
            set ecolor ""
            foreach c [split $x3dColor] {append ecolor "[expr {$c*.5}] "}
            if {$ao == "tessellated_shell" && [info exists entCount(tessellated_solid)]} {
              set ecolor "0 0 0"
              set msg "Triangular faces in tessellated shells are outlined in black."
              if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
            }

            set defstr ""
            if {$nplace > 1} {set defstr " DEF='mesh$objID'"}
            puts $f "<Shape$defstr><Appearance><Material emissiveColor='$ecolor'></Material></Appearance>"
            puts $f " <IndexedLineSet coordIndex='[string trim $x3dMesh]'><Coordinate USE='coord$tessIndexCoord($objID)'></Coordinate></IndexedLineSet></Shape>"
          } else {
            puts $f "<Shape USE='mesh$objID'></Shape>"
          }
        }
      }

      incr nshape
      if {[expr {$nshape%1000}] == 0} {outputMsg "  $nshape"}

# end transform
      if {[info exists endTransform]} {puts $f $endTransform}
    }
  }
  set x3dCoord ""
  set x3dIndex ""
  update idletasks
}

# -------------------------------------------------------------------------------
# datum targets
proc x3dDatumTarget {maxxyz} {
  global datumTargetView dttype viz x3dFile x3dMsg

  outputMsg " Processing datum targets" green
  puts $x3dFile "\n<!-- DATUM TARGETS -->\n<Switch whichChoice='0' id='swDTR'><Group>"

  set dttype ""
  foreach idx [array names datumTargetView] {
    set shape [lindex $datumTargetView($idx) 0]
    set color "1 0 0"
    set feat ""
    if {[string first "feature" $idx] != -1} {
      set color "0 .5 0"
      set feat " feature"
    }
    set endTransform 0

# check for handle
    if {[string first "handle" $shape] == -1} {
      set e3 ""

# position and orientation
      set origin [lindex [lindex $datumTargetView($idx) 1] 0]
      set axis   [lindex [lindex $datumTargetView($idx) 1] 1]
      set refdir [lindex [lindex $datumTargetView($idx) 1] 2]
      if {$origin == "0. 0. 0."} {
        set msg "Datum target(s) located at the origin."
        if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
      }

# handle, then shape is with geometric entity (cartesian_point, line, and circle are supported)
    } else {
      set e3 [lindex $datumTargetView($idx) 0]
      set shape [$e3 Type]
      if {$shape == "trimmed_curve"} {
        set e3 [[[$e3 Attributes] Item [expr 2]] Value]
        if {[$e3 Type] == "line"}   {set shape [$e3 Type]}
        if {[$e3 Type] == "circle"} {set shape "circular curve"}
      } elseif {$shape == "circle"} {
        set shape "circular curve"
      }
    }

# text
    set textOrigin "0 0 0"
    set target [lindex $datumTargetView($idx) end]
    set len [string length $target]
    if {$len < 2 || $len > 5 || ![string is alpha [string index $target 0]]} {set target ""}
    set textJustify "BEGIN"
    if {$e3 != ""} {set textJustify "END"}
    if {$target != ""} {puts $x3dFile "<!-- $target -->"}

# process different shapes
    if {[catch {
      switch -- $shape {
        point -
        cartesian_point {
# generate point
          set rad [trimNum [expr {$maxxyz*0.00125}]]
          if {$e3 != ""} {set origin [vectrim [[[$e3 Attributes] Item [expr 2]] Value]]}
          puts $x3dFile "<Transform translation='$origin'><Shape><Appearance><Material diffuseColor='$color' emissiveColor='$color'></Material></Appearance><Sphere radius='$rad'></Sphere></Shape>"
          set target " $target"
          set viz(DTR) 1
          set endTransform 1
        }

        line {
# generate line
          if {$e3 == ""} {
            puts $x3dFile [x3dTransform $origin $axis $refdir "$shape datum target"]
            set x [trimNum [lindex [lindex $datumTargetView($idx) 2] 1]]
            puts $x3dFile " <Shape><Appearance><Material emissiveColor='$color'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0 0 0 $x 0 0'></Coordinate></IndexedLineSet></Shape>"
            set textOrigin "[trimNum [expr {$x*0.5}]] 0 0"
            set endTransform 1
          } else {
            set e4 [[[$e3 Attributes] Item [expr 2]] Value]
            set coord1 [vectrim [[[$e4 Attributes] Item [expr 2]] Value]]
            set e5 [[[$e3 Attributes] Item [expr 3]] Value]
            set mag [[[$e5 Attributes] Item [expr 3]] Value]
            set e6 [[[$e5 Attributes] Item [expr 2]] Value]
            set dir [[[$e6 Attributes] Item [expr 2]] Value]
            set coord2 [vectrim [vecadd $coord1 [vecmult $dir $mag]]]
            puts $x3dFile "<Shape><Appearance><Material emissiveColor='$color'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='$coord1 $coord2'></Coordinate></IndexedLineSet></Shape>"
            set textOrigin [vectrim [vecmult [vecadd $coord1 $coord2] 0.5]]
          }
          set viz(DTR) 1
        }

        rectangle {
# generate rectangle
          puts $x3dFile [x3dTransform $origin $axis $refdir "$shape datum target"]
          foreach i {2 3} {
            set type [lindex $datumTargetView($idx) $i]
            switch -- [lindex $type 0] {
              "target length" {set x [trimNum [expr {[lindex $type 1]*0.5}]]}
              "target width"  {set y [trimNum [expr {[lindex $type 1]*0.5}]]}
            }
          }
          puts $x3dFile " <Shape><Appearance><Material emissiveColor='$color'></Material></Appearance><IndexedLineSet coordIndex='0 1 2 3 0 -1'><Coordinate point='-$x -$y 0 $x -$y 0 $x $y 0 -$x $y 0'></Coordinate></IndexedLineSet></Shape>"
          puts $x3dFile " <Shape><Appearance><Material diffuseColor='$color' transparency='0.8'></Material></Appearance><IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'><Coordinate point='-$x -$y 0 $x -$y 0 $x $y 0 -$x $y 0'></Coordinate></IndexedFaceSet></Shape>"
          set endTransform 1
          set viz(DTR) 1
        }

        circle -
        "circular curve" {
# generate circle
          if {$e3 == ""} {
            set rad [trimNum [expr {[lindex [lindex $datumTargetView($idx) 2] 1]*0.5}]]
          } else {
            set e4 [[[$e3 Attributes] Item [expr 2]] Value]
            set rad [[[$e3 Attributes] Item [expr 3]] Value]
            set a2p3d [x3dGetA2P3D $e4]
            set origin [lindex $a2p3d 0]
            set axis   [lindex $a2p3d 1]
            set refdir [lindex $a2p3d 2]
          }
          puts $x3dFile [x3dTransform $origin $axis $refdir "$shape datum target"]
          set ns 48
          set angle 0.
          set dlt [expr {6.28319/$ns}]
          set index ""
          for {set i 0} {$i < $ns} {incr i} {append index "$i "}
          set coord ""
          for {set i 0} {$i < $ns} {incr i} {
            append coord "[trimNum [expr {$rad*cos($angle)}]] "
            append coord "[trimNum [expr {$rad*sin($angle)}]] "
            append coord "0 "
            set angle [expr {$angle+$dlt}]
          }
          puts $x3dFile " <Shape><Appearance><Material emissiveColor='$color'></Material></Appearance><IndexedLineSet coordIndex='$index 0 -1'><Coordinate point='$coord'></Coordinate></IndexedLineSet></Shape>"
          if {$shape == "circle"} {
            puts $x3dFile " <Shape><Appearance><Material diffuseColor='$color' transparency='0.8'></Material></Appearance><IndexedFaceSet solid='false' coordIndex='$index -1'><Coordinate point='$coord'></Coordinate></IndexedFaceSet></Shape>"
          } else {
            set textOrigin "$rad 0 0"
          }
          set endTransform 1
          set viz(DTR) 1
        }

        advanced_face {
# for advanced face, look for circles and lines
          set e1 $e3
          set e2 [[[$e1 Attributes] Item [expr 3]] Value]

# if in a plane, follow face_outer_bounds and face_bounds to ...
          if {[$e2 Type] == "plane"} {
            set e2s [[[$e1 Attributes] Item [expr 2]] Value]
            set igeom 0
            set coord ""
            set ncoord 0

# get number of face bounds
            set nbound 0
            ::tcom::foreach e2 $e2s {incr nbound}

            ::tcom::foreach e2 $e2s {
              set e3 [[[$e2 Attributes] Item [expr 2]] Value]
              set e4s [[[$e3 Attributes] Item [expr 2]] Value]

# get number and types of geometric entities defining the edges
              set ngeom 0
              set gtypes {}
              ::tcom::foreach e4 $e4s {
                incr ngeom
                set e5 [[[$e4 Attributes] Item [expr 4]] Value]
                set e6 [[[$e5 Attributes] Item [expr 4]] Value]
                if {[lsearch $gtypes [$e6 Type]] == -1} {lappend gtypes [$e6 Type]}
              }

# check for only multiple circles or ellipses
              set onlyCircle 0
              if {[llength $gtypes] == 1} {if {$gtypes == "circle" || $gtypes == "ellipse"} {set onlyCircle 1}}

              ::tcom::foreach e4 $e4s {
                set e5 [[[$e4 Attributes] Item [expr 4]] Value]
                set e6 [[[$e5 Attributes] Item [expr 4]] Value]
                incr igeom

# advanced face circle and ellipse edges
                if {[$e6 Type] == "circle" || [$e6 Type] == "ellipse"} {
                  if {$nbound == 1 && ($ngeom == 1 || $onlyCircle)} {
                    set rad [[[$e6 Attributes] Item [expr 3]] Value]
                    set scale ""

# check ellipse axes
                    if {[$e6 Type] == "ellipse"} {
                      set rad1 [[[$e6 Attributes] Item [expr 4]] Value]
                      set sy [expr {$rad1/$rad}]
                      set scale "1 $sy 1"
                      set dsy [trimNum [expr {abs($sy-1.)}]]
                      if {$dsy <= 0.05} {errorMsg " Datum target '[$e6 Type]' axes ($rad,$rad1) are almost identical."}
                    }

# transform for circle
                    if {!$onlyCircle || $igeom == 1} {
                      set a2p3d [x3dGetA2P3D [[[$e6 Attributes] Item [expr 2]] Value]]
                      puts $x3dFile [x3dTransform [lindex $a2p3d 0] [lindex $a2p3d 1] [lindex $a2p3d 2] "$shape circle datum target" $scale]
                    }

# generate coordinates
                    incr ncoord 48
                    set angle 0.
                    set dlt [expr {6.28319/$ncoord}]
                    for {set i 0} {$i < $ncoord} {incr i} {
                      append coord "[trimNum [expr {$rad*cos($angle)}]] "
                      append coord "[trimNum [expr {$rad*sin($angle)}]] "
                      append coord "0 "
                      set angle [expr {$angle+$dlt}]
                      if {$i == 0 && $igeom == 1} {set textOrigin $coord}
                    }
                    set endTransform 1
                  } else {
                    set msg "Datum target$feat edge defined by multiple types of curves is not supported."
                    errorMsg " $msg"
                    if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
                  }

# advanced face line edges
                } elseif {[$e6 Type] == "line"} {
                  set e7 [[[$e6 Attributes] Item [expr 2]] Value]
                  set pt [vectrim [[[$e7 Attributes] Item [expr 2]] Value]]
                  append coord "$pt "
                  incr ncoord
                  if {$ncoord == 1 && $igeom == 1} {set textOrigin $pt}

# not a circle or line
                } else {
                  set target ""
                  set msg "Datum target$feat edge defined by '[$e6 Type]' is not supported."
                  errorMsg " $msg"
                  if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
                }
              }
            }

# shape for circles and lines
            if {$coord != ""} {
              set index ""
              for {set i 0} {$i < $ncoord} {incr i} {append index "$i "}
              puts $x3dFile " <Shape><Appearance><Material emissiveColor='$color'></Material></Appearance><IndexedLineSet coordIndex='$index 0 -1'><Coordinate point='$coord'></Coordinate></IndexedLineSet></Shape>"
              puts $x3dFile " <Shape><Appearance><Material diffuseColor='$color' transparency='0.8'></Material></Appearance><IndexedFaceSet solid='false' coordIndex='$index -1'><Coordinate point='$coord'></Coordinate></IndexedFaceSet></Shape>"
              set viz(DTR) 1
            }

# non planes are not supported
          } else {
            set target ""
            set msg "Datum target$feat surface defined by '[$e2 Type]' is not supported."
            errorMsg " $msg"
            if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
          }
        }

        default {
          set target ""
          set msg "Datum target$feat defined by '$shape' is not supported."
          errorMsg " $msg"
          if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
        }
      }

# small coordinate triad
      if {$shape != "point" && $shape != "cartesian_point" && $shape != "advanced_face" && [string first "feature" $idx] == -1} {
        set size [trimNum [expr {$maxxyz*0.005}]]
        puts $x3dFile " <Shape><Appearance><Material emissiveColor='1 0 0'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. $size 0. 0.'></Coordinate></IndexedLineSet></Shape>"
        puts $x3dFile " <Shape><Appearance><Material emissiveColor='0 .5 0'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. 0. $size 0.'></Coordinate></IndexedLineSet></Shape>"
        puts $x3dFile " <Shape><Appearance><Material emissiveColor='0 0 1'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. 0. 0. $size'></Coordinate></IndexedLineSet></Shape>"
      }

# datum target label
      if {$target != ""} {
        set size [trimNum [expr {$maxxyz*0.01}]]
        set trans ""
        if {$textOrigin != "0 0 0"} {set trans " translation='$textOrigin'"}
        puts $x3dFile " <Transform$trans scale='$size $size $size'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"$target\"'><FontStyle family='\"SANS\"' justify='\"$textJustify\"'></FontStyle></Text><Appearance><Material diffuseColor='$color'></Material></Appearance></Shape></Billboard></Transform>"
      }

# end transform
      if {$endTransform} {puts $x3dFile "</Transform>"}

    } emsg]} {
      errorMsg "ERROR viewing a '$shape' datum target$feat ($target): $emsg"
    }
  }
  puts $x3dFile "</Group></Switch>"
  catch {unset datumTargetView}
  catch {unset dttype}
}

# -------------------------------------------------------------------------------
# supplemental geometry
proc x3dSuppGeom {maxxyz} {
  global cgrObjects axesDef planeDef recPracNames syntaxErr tessSuppGeomFile tessSuppGeomFileName trimVal x3dFile x3dMsg
  global objDesign

  set size [trimNum [expr {$maxxyz*0.025}]]
  set tsize [trimNum [expr {$size*0.33}]]
  set axesDef {}
  set planeDef {}

  outputMsg " Processing supplemental geometry" green
  puts $x3dFile "\n<!-- SUPPLEMENTAL GEOMETRY -->\n<Switch whichChoice='0' id='swSMG'><Group>"
  if {![info exists cgrObjects]} {set cgrObjects [$objDesign FindObjects [string trim constructive_geometry_representation]]}
  ::tcom::foreach e0 $cgrObjects {
    set a1 [[$e0 Attributes] Item [expr 2]]

# process all items
    ::tcom::foreach e2 [$a1 Value] {
      if {[catch {
        set ename [$e2 Type]

        switch $ename {
          line -
          polyline {x3dSuppGeomLine $e2 $tsize $ename}
          circle -
          ellipse  {x3dSuppGeomCircle $e2 $tsize $ename}
          plane    {x3dSuppGeomPlane $e2 $size}
          cartesian_point     {x3dSuppGeomPoint $e2 $tsize}
          axis2_placement_3d  {x3dSuppGeomAxis $e2 $size $tsize}
          cylindrical_surface {x3dSuppGeomCylinder $e2 $tsize}

          trimmed_curve -
          composite_curve -
          geometric_curve_set {
            catch {unset trimVal}
            set trimmedCurves {}

# get trimmed curves
            if {$ename == "trimmed_curve"} {
              lappend trimmedCurves $e2

# composite_curve -> composite_curve_segment -> trimmed_curve
            } elseif {$ename == "composite_curve"} {
              ::tcom::foreach ccs [[[$e2 Attributes] Item [expr 2]] Value] {
                lappend trimmedCurves [[[$ccs Attributes] Item [expr 3]] Value]
              }

# geometric_curve_set -> list of trimmed_curve or composite_curve -> trimmed_curve
            } elseif {$ename == "geometric_curve_set"} {
              set e3s [[[$e2 Attributes] Item [expr 2]] Value]
              foreach e3 $e3s {
                set ename1 [$e3 Type]
                switch $ename1 {
                  line -
                  polyline {x3dSuppGeomLine $e3 $tsize $ename1}
                  circle -
                  ellipse {x3dSuppGeomCircle $e3 $tsize $ename1}
                  cartesian_point {x3dSuppGeomPoint $e3 $tsize}
                  trimmed_curve {lappend trimmedCurves $e3}
                  composite_curve {::tcom::foreach ccs [[[$e3 Attributes] Item [expr 2]] Value] {lappend trimmedCurves [[[$ccs Attributes] Item [expr 3]] Value]}}
                  default {
                    set msg "Supplemental geometry for '$ename1' in 'geometric_curve_set' is not supported."
                    errorMsg " $msg"
                    if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
                  }
                }
              }
            }

# process trimmed curves collected from above
            foreach tc $trimmedCurves {

# trimming with values OK, cartesian_points for lines, but circles NG, do not delete the meaningless 'catch'
              set trimVal(1) [[[$tc Attributes] Item [expr 3]] Value]
              set trimVal(2) [[[$tc Attributes] Item [expr 4]] Value]
              catch {set tmp "[$trimVal(1) Type][$trimVal(2) Type]"}

              foreach idx [list 1 2] {
                if {[llength $trimVal($idx)] == 2} {
                  if {[string is double [lindex $trimVal($idx) 0]]} {set trimVal($idx) [lindex $trimVal($idx) 0]}
                  if {[string is double [lindex $trimVal($idx) 1]]} {set trimVal($idx) [lindex $trimVal($idx) 1]}
                }
                if {[string first "handle" $trimVal($idx)] == -1} {
                  if {[expr {abs($trimVal($idx))}] > 1000.} {
                    set nval [trimNum [expr {10.*$trimVal($idx)/abs($trimVal($idx))}]]
                    errorMsg "Trim value [trimNum $trimVal($idx)] for a 'trimmed_curve' is very large, using $nval instead."
                    set trimVal($idx) $nval
                  }
                }
              }

# line, polyline, circle, ellipse trimmed curves
              set e3 [[[$tc Attributes] Item [expr 2]] Value]
              set ename2 [$e3 Type]
              switch $ename2 {
                line -
                polyline {x3dSuppGeomLine $e3 $tsize $ename2}
                circle -
                ellipse {x3dSuppGeomCircle $e3 $tsize $ename2}
                default {
                  set msg "Supplemental geometry for '[$e3 Type]' in 'trimmed_curve' is not supported."
                  errorMsg " $msg"
                  if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
                }
              }
            }
          }

          shell_based_surface_model {
            set cylIDs {}
            set e3 [lindex [[[$e2 Attributes] Item [expr 2]] Value] 0]
            set e4s [[[$e3 Attributes] Item [expr 2]] Value]
            ::tcom::foreach e4 $e4s {
              set e5 [lindex [[[$e4 Attributes] Item [expr 3]] Value] 0]
              set ename5 [$e5 Type]
              switch $ename5 {
                plane {x3dSuppGeomPlane $e5 $size}
                cylindrical_surface {
                  if {[lsearch $cylIDs [$e5 P21ID]] == -1} {
                    lappend cylIDs [$e5 P21ID]
                    x3dSuppGeomCylinder $e5 $tsize
                  }
                }
                default {
                  set msg "Supplemental geometry for '[$e5 Type]' in 'shell_based_surface_model' is not supported."
                  errorMsg " $msg"
                  if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
                }
              }
            }
          }

          default {
            if {$ename != "tessellated_shell" && $ename != "tessellated_wire"} {
              if {$ename == "direction"} {
                set msg "Supplemental geometry for '$ename' is not valid."
                if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
                set msg "Syntax Error: Supplemental geometry for '$ename' is not valid.  ($recPracNames(suppgeom), Sec. 4.2)"
                errorMsg $msg
                lappend syntaxErr(constructive_geometry_representation) [list [$e0 P21ID] "items" $msg]
              } else {
                set msg "Supplemental geometry for '$ename' is not supported."
                errorMsg " $msg"
                if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
              }
            }
          }
        }

# error
      } emsg]} {
        errorMsg " ERROR adding '$ename' Supplemental Geometry: $emsg"
      }
    }
  }

# check for tessellated edges that are supplemental geometry
  if {[info exists tessSuppGeomFile]} {
    close $tessSuppGeomFile
    if {[file size $tessSuppGeomFileName] > 0} {
      set f [open $tessSuppGeomFileName r]
      puts $x3dFile "<!-- TESSELLATED GEOMETRY that is SUPPLEMENTAL GEOMETRY -->"
      while {[gets $f line] >= 0} {puts $x3dFile $line}
      close $f
    }
    catch {file delete -force -- $tessSuppGeomFileName}
    unset tessSuppGeomFile
    unset tessSuppGeomFileName
  }
  puts $x3dFile "</Group></Switch>"
}

# -------------------------------------------------------------------------------
# supplemental geometry for axis
proc x3dSuppGeomAxis {e2 size tsize} {
  global axesDef viz x3dColorsUsed x3dFile

  set e3 $e2
  set a2p3d [x3dGetA2P3D $e3]
  set origin [lindex $a2p3d 0]
  set axis   [lindex $a2p3d 1]
  set refdir [lindex $a2p3d 2]
  set transform [x3dTransform $origin $axis $refdir "supplemental geometry axes"]

# check for axis color
  set axisColor ""
  if {[catch {
    set e4s [$e3 GetUsedIn [string trim styled_item] [string trim item]]
    ::tcom::foreach e4 $e4s {
      set e5s [[[$e4 Attributes] Item [expr 2]] Value]
      ::tcom::foreach e5 $e5s {
        set e6 [[[$e5 Attributes] Item [expr 1]] Value]
        if {[$e6 Type] == "curve_style"} {
          set e7 [[[$e6 Attributes] Item [expr 4]] Value]
          if {$e7 != ""} {
            if {[$e7 Type] == "colour_rgb"} {
              set j 0
              ::tcom::foreach a7 [$e7 Attributes] {
                if {$j > 0} {append axisColor "[trimNum [$a7 Value] 3] "}
                incr j
              }
              set axisColor [string trim $axisColor]
            } elseif {[$e7 Type] == "draughting_pre_defined_colour"} {
              set axisColor [x3dPreDefinedColor [[[$e7 Attributes] Item [expr 1]] Value]]
            } else {
              errorMsg " Color '[$e7 Type]' for 'axis2_placement_3d' supplemental geometry is not supported."
            }
          }
        } else {
          errorMsg " Color defined with '[$e6 Type]' for 'axis2_placement_3d' supplemental geometry is not supported."
        }
      }
    }
  } emsg]} {
    errorMsg " ERROR getting color for 'axis2_placement_3d' supplemental geometry: $emsg"
  }

  if {$axisColor == ""} {
    set id [lsearch $axesDef $size]
    if {$id != -1} {
      puts $x3dFile "$transform<Group USE='axes$id'></Group>"
    } else {
      lappend axesDef $size
      puts $x3dFile $transform
      puts $x3dFile " <Group DEF='axes[expr {[llength $axesDef]-1}]'><Shape><Appearance><Material emissiveColor='1 0 0'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. $size 0. 0.'></Coordinate></IndexedLineSet></Shape>"
      puts $x3dFile " <Shape><Appearance><Material emissiveColor='0 .5 0'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. 0. $size 0.'></Coordinate></IndexedLineSet></Shape>"
      puts $x3dFile " <Shape><Appearance><Material emissiveColor='0 0 1'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. 0. 0. $size'></Coordinate></IndexedLineSet></Shape></Group>"
    }
  } else {
    set id [lsearch $axesDef "$size $axisColor"]
    if {$id != -1} {
      puts $x3dFile "$transform<Group USE='axes$id'></Group>"
    } else {
      lappend axesDef "$size $axisColor"
      set sz [trimNum [expr {$size*1.5}]]
      set tsize [trimNum [expr {$sz*0.33}]]
      puts $x3dFile $transform
      puts $x3dFile " <Group DEF='axes[expr {[llength $axesDef]-1}]'><Shape><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. $sz 0. 0.'></Coordinate></IndexedLineSet><Appearance><Material emissiveColor='$axisColor'></Material></Appearance></Shape>"
      puts $x3dFile " <Shape><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. 0. $sz 0.'></Coordinate></IndexedLineSet><Appearance><Material emissiveColor='$axisColor'></Material></Appearance></Shape>"
      puts $x3dFile " <Shape><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0. 0. 0. 0. 0. $sz'></Coordinate></IndexedLineSet><Appearance><Material emissiveColor='$axisColor'></Material></Appearance></Shape>"
      puts $x3dFile " <Transform translation='$sz 0 0' scale='$tsize $tsize $tsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"X\"'><FontStyle family='\"SANS\"'></FontStyle></Text><Appearance><Material diffuseColor='$axisColor'></Material></Appearance></Shape></Billboard></Transform>"
      puts $x3dFile " <Transform translation='0 $sz 0' scale='$tsize $tsize $tsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"Y\"'><FontStyle family='\"SANS\"'></FontStyle></Text><Appearance><Material diffuseColor='$axisColor'></Material></Appearance></Shape></Billboard></Transform>"
      puts $x3dFile " <Transform translation='0 0 $sz' scale='$tsize $tsize $tsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"Z\"'><FontStyle family='\"SANS\"'></FontStyle></Text><Appearance><Material diffuseColor='$axisColor'></Material></Appearance></Shape></Billboard></Transform></Group>"
      lappend x3dColorsUsed $axisColor
    }
  }

  set nsize [trimNum [expr {$tsize*0.5}]]
  set tcolor "1 0 0"
  set name [[[$e2 Attributes] Item [expr 1]] Value]
  if {$axisColor != ""} {set tcolor $axisColor}
  if {$name != ""} {
    regsub -all "'" $name "" name
    puts $x3dFile " <Transform scale='$nsize $nsize $nsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"$name\"'><FontStyle family='\"SANS\"' justify='\"BEGIN\"'></FontStyle></Text><Appearance><Material diffuseColor='$tcolor'></Material></Appearance></Shape></Billboard></Transform>"
  }
  puts $x3dFile "</Transform>"
  set viz(SMG) 1
}

# -------------------------------------------------------------------------------
# supplemental geometry for point and the origin of a hole
proc x3dSuppGeomPoint {e2 tsize {thruHole ""} {holeName ""}} {
  global sphereDef viz x3dFile

  if {[catch {

# get cartesian_point name attribute or use hole name
    set name [[[$e2 Attributes] Item [expr 1]] Value]
    if {$holeName != ""} {set name $holeName}
    set name [string trim $name]

# append THRU for thru holes
    if {$thruHole == 1} {
      if {[string length $name] > 0} {
        append name " (THRU)"
      } else {
        append name "THRU"
      }
    }
    set coord1 [[[$e2 Attributes] Item [expr 2]] Value]

# point is a black emissive sphere
    set id [lsearch $sphereDef $tsize]
    if {$id != -1} {
      puts $x3dFile "<Transform translation='[vectrim $coord1]'><Shape USE='point$id'></Shape></Transform>"
    } else {
      lappend sphereDef $tsize
      puts $x3dFile "<Transform translation='[vectrim $coord1]'><Shape DEF='point[expr {[llength $sphereDef]-1}]'><Sphere radius='[trimNum [expr {$tsize*0.05}]]'></Sphere><Appearance><Material diffuseColor='0 0 0' emissiveColor='0 0 0'></Material></Appearance></Shape></Transform>"
    }

# point name
    if {$name != ""} {
      set nsize [trimNum [expr {$tsize*0.5}]]
      puts $x3dFile " <Transform translation='[vectrim $coord1]' scale='$nsize $nsize $nsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"$name\"'><FontStyle family='\"SANS\"' justify='\"BEGIN\"'></FontStyle></Text><Appearance><Material diffuseColor='0 0 0'></Material></Appearance></Shape></Billboard></Transform>"
    }
    set viz(SMG) 1
  } emsg]} {
    errorMsg "ERROR adding 'point' supplemental geometry: $emsg"
  }
}

# -------------------------------------------------------------------------------
# supplemental geometry for line, polyline
proc x3dSuppGeomLine {e3 tsize {type "line"}} {
  global trimVal viz x3dFile

  if {[catch {
    if {$type == "line"} {
      set e4 [[[$e3 Attributes] Item [expr 2]] Value]
      set coord1 [vectrim [[[$e4 Attributes] Item [expr 2]] Value]]
      set e5 [[[$e3 Attributes] Item [expr 3]] Value]
      set mag [[[$e5 Attributes] Item [expr 3]] Value]
      set e6 [[[$e5 Attributes] Item [expr 2]] Value]
      set dir [[[$e6 Attributes] Item [expr 2]] Value]
      set coord2 [vectrim [vecmult $dir $mag]]

# trim line
      if {[info exists trimVal(2)]} {

# trim with real number
        if {[string first "handle" $trimVal(2)] == -1} {
          if {$trimVal(1) != 0.} {set origin [vectrim [vecmult $dir [expr {$trimVal(1)*$mag}]]]}
          set coord2 [vectrim [vecmult $dir [expr {$trimVal(2)*$mag}]]]

# trim with cartesian points
        } else {
          foreach idx [list 1 2] {set trim($idx) [[[$trimVal($idx) Attributes] Item [expr 2]] Value]}
          set coord1 [vectrim $trim(1)]
          set coord2 [vectrim [vecsub $trim(2) $trim(1)]]
        }
      }

      set origin $coord1
      set coord2 [vectrim [vecadd $coord1 $coord2]]
      set points "$coord1 $coord2"
      set npoints 2

# polyline
    } else {
      set e4s [[[$e3 Attributes] Item [expr 2]] Value]
      set points ""
      set npoints 0
      ::tcom::foreach e4 $e4s {
        append points "[vectrim [[[$e4 Attributes] Item [expr 2]] Value]] "
        incr npoints
        if {$npoints == 1} {set origin $points}
      }
    }

# index
    set index ""
    for {set i 0} {$i < $npoints} {incr i} {append index "$i "}
    append index "-1"

# line geometry
    puts $x3dFile "<Shape><IndexedLineSet coordIndex='$index'><Coordinate point='$points'></Coordinate></IndexedLineSet><Appearance><Material emissiveColor='1 0 1'></Material></Appearance></Shape>"

# line name at beginning
    set name [[[$e3 Attributes] Item [expr 1]] Value]
    if {$name != ""} {
      set nsize [trimNum [expr {$tsize*0.5}]]
      puts $x3dFile " <Transform translation='$origin' scale='$nsize $nsize $nsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"$name\"'><FontStyle family='\"SANS\"' justify='\"BEGIN\"'></FontStyle></Text><Appearance><Material diffuseColor='1 0 1'></Material></Appearance></Shape></Billboard></Transform>"
    }
    set viz(SMG) 1

  } emsg]} {
    errorMsg "ERROR adding '$type' supplemental geometry: $emsg"
  }
}

# -------------------------------------------------------------------------------
# supplemental geometry for circle, ellipse
proc x3dSuppGeomCircle {e3 tsize {type "circle"}} {
  global DTR trimVal viz x3dFile x3dMsg

  if {[catch {
    set e4 [[[$e3 Attributes] Item [expr 2]] Value]
    set rad [[[$e3 Attributes] Item [expr 3]] Value]

    set scale ""
    if {$type == "ellipse"} {
      set rad1 [[[$e3 Attributes] Item [expr 4]] Value]
      set sy [expr {$rad1/$rad}]
      set scale "1 $sy 1"
      set dsy [trimNum [expr {abs($sy-1.)}]]
      if {$dsy <= 0.05} {errorMsg " Supplemental geometry $type axes ($rad,$rad1) are almost identical."}
    }

# circle position and orientation
    set a2p3d [x3dGetA2P3D $e4]
    set origin [lindex $a2p3d 0]
    set axis   [lindex $a2p3d 1]
    set refdir [lindex $a2p3d 2]
    set transform [x3dTransform $origin $axis $refdir "supplemental geometry $type" $scale]
    puts $x3dFile $transform

# generate circle, account for trimming
# lim is the limit on an angle before deciding it is in degrees to convert to radians
    set ns 48
    set angle 0.
    set dlt [expr {6.28319/$ns}]
    set trimmed 0
    set lim 6.28319

# trim with angles
    if {[info exists trimVal(1)]} {
      if {[string first "handle" $trimVal(1)] == -1} {
        set angle $trimVal(1)
        set conv 1.
        if {$trimVal(1) > $lim && $trimVal(2) > $lim} {
          set conv $DTR
          set angle [expr {$angle*$conv}]
        }
        set dlt [expr {$conv*($trimVal(2)-$trimVal(1))/$ns}]
        incr ns
        set trimmed 1

# trim with cartesian points
      } else {

# compute angles from cartesian points (doesn't work yet)
        #foreach idx [list 1 2] {
        #  set trim($idx) [[[$trimVal($idx) Attributes] Item [expr 2]] Value]
        #  set vec($idx) [vecnorm [vecsub $trim($idx) $origin]]
        #  outputMsg "$idx / trim point [vectrim $trim($idx)] / origin [vectrim $origin] / vector [vectrim $vec($idx)] / axis [vectrim $axis] / refdir [vectrim $refdir]" red
        #  outputMsg "angle [vecangle $vec($idx) $axis]"
        #}
        set msg "Supplemental geometry '$type' trimmed by 'cartesian_point' are not trimmed."
        errorMsg " $msg"
        if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
      }
    }
    set index ""
    for {set i 0} {$i < $ns} {incr i} {append index "$i "}
    if {!$trimmed} {append index "0 "}
    append index "-1"

    set coord ""
    for {set i 0} {$i < $ns} {incr i} {
      append coord "[trimNum [expr {$rad*cos($angle)}]] "
      append coord "[trimNum [expr {$rad*sin($angle)}]] "
      append coord "0 "
      set angle [expr {$angle+$dlt}]
      if {$i == 0} {set origin $coord}
    }

# circle geometry and possible name
    puts $x3dFile " <Shape><IndexedLineSet coordIndex='$index'><Coordinate point='$coord'></Coordinate></IndexedLineSet><Appearance><Material emissiveColor='1 0 1'></Material></Appearance></Shape>"
    set name [[[$e3 Attributes] Item [expr 1]] Value]
    if {$name != ""} {
      set nsize [trimNum [expr {$tsize*0.5}]]
      puts $x3dFile " <Transform translation='$origin' scale='$nsize $nsize $nsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"$name\"'><FontStyle family='\"SANS\"' justify='\"BEGIN\"'></FontStyle></Text><Appearance><Material diffuseColor='1 0 1'></Material></Appearance></Shape></Billboard></Transform>"
    }
    puts $x3dFile "</Transform>"
    set viz(SMG) 1

  } emsg]} {
    errorMsg "ERROR adding '$type' supplemental geometry: $emsg"
  }
}

# -------------------------------------------------------------------------------
# supplemental geometry for plane
proc x3dSuppGeomPlane {e2 size} {
  global planeDef viz x3dFile x3dMsg

  if {[catch {
    set e3 [[[$e2 Attributes] Item [expr 2]] Value]

# plane position and orientation
    set a2p3d [x3dGetA2P3D $e3]
    set origin [lindex $a2p3d 0]
    set axis   [lindex $a2p3d 1]
    set refdir [lindex $a2p3d 2]
    set transform [x3dTransform $origin $axis $refdir "supplemental geometry plane"]

# plane geometry
    set nsize [trimNum [expr {$size*2.}]]
    set id [lsearch $planeDef $nsize]
    if {$id != -1} {
      puts $x3dFile "$transform<Group USE='plane$id'></Group>"
    } else {
      lappend planeDef $nsize
      puts $x3dFile $transform
      puts $x3dFile " <Group DEF='plane[expr {[llength $planeDef]-1}]'><Shape><IndexedLineSet coordIndex='0 1 2 3 0 -1'><Coordinate point='-$nsize -$nsize 0. $nsize -$nsize 0. $nsize $nsize 0. -$nsize $nsize 0.'></Coordinate></IndexedLineSet><Appearance><Material emissiveColor='0 0 1'></Material></Appearance></Shape>"
      puts $x3dFile " <Shape><IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'><Coordinate point='-$nsize -$nsize 0. $nsize -$nsize 0. $nsize $nsize 0. -$nsize $nsize 0.'></Coordinate></IndexedFaceSet><Appearance><Material diffuseColor='0 0 1' transparency='0.8'></Material></Appearance></Shape></Group>"
    }

# plane name at one corner
    set name [[[$e2 Attributes] Item [expr 1]] Value]
    if {$name != ""} {
      set tsize [trimNum [expr {$size*0.33}]]
      puts $x3dFile " <Transform translation='-$nsize -$nsize 0.' scale='$tsize $tsize $tsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"$name\"'><FontStyle family='\"SANS\"' justify='\"BEGIN\"'></FontStyle></Text><Appearance><Material diffuseColor='0 0 1'></Material></Appearance></Shape></Billboard></Transform>"
    }
    puts $x3dFile "</Transform>"
    set viz(SMG) 1

# check if the plane is bounded
    set bnds [$e2 GetUsedIn [string trim advanced_face] [string trim faced_geometry]]
    set bound 0
    ::tcom::foreach bnd $bnds {set bound 1}
    if {$bound} {
      set msg "Bounding edges for supplemental geometry 'plane' are not supported."
      errorMsg " $msg"
      if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
    }

  } emsg]} {
    errorMsg "ERROR adding 'plane' supplemental geometry: $emsg"
  }
}

# -------------------------------------------------------------------------------
# supplemental geometry for cylinder
proc x3dSuppGeomCylinder {e2 size} {
  global viz x3dFile x3dMsg

  if {[catch {
    set e3 [[[$e2 Attributes] Item [expr 2]] Value]
    set rad [[[$e2 Attributes] Item [expr 3]] Value]

# cylinder position and orientation
    set a2p3d [x3dGetA2P3D $e3]
    set origin [lindex $a2p3d 0]
    set axis   [lindex $a2p3d 1]
    set refdir [lindex $a2p3d 2]
    set transform [x3dTransform $origin $axis $refdir "supplemental geometry cylinder"]
    puts $x3dFile "$transform<Transform rotation='1 0 0 1.5708'>"

# cylinder geometry
    puts $x3dFile "  <Shape><Cylinder radius='$rad' height='[trimNum [expr {$size*10.}]]' top='false' bottom='false' solid='false'></Cylinder><Appearance><Material diffuseColor='0 0 1' transparency='0.8'></Material></Appearance></Shape>"
    puts $x3dFile "</Transform></Transform>"

# cylinder name at origin
    set name [[[$e2 Attributes] Item [expr 1]] Value]
    if {$name != ""} {
      set tsize [trimNum [expr {$size*0.33}]]
      puts $x3dFile " <Transform translation='$origin' scale='$tsize $tsize $tsize'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"$name\"'><FontStyle family='\"SANS\"' justify='\"BEGIN\"'></FontStyle></Text><Appearance><Material diffuseColor='0 0 1'></Material></Appearance></Shape></Billboard></Transform>"
    }
    set viz(SMG) 1

# check if the cylinder is bounded
    set bnds [$e2 GetUsedIn [string trim advanced_face] [string trim face_geometry]]
    set bound 0
    ::tcom::foreach e0 $bnds {set bound 1}
    if {$bound} {
      set msg "Bounding edges for supplemental geometry 'cylindrical_surface' are not supported."
      errorMsg " $msg"
      if {[lsearch $x3dMsg $msg] == -1} {lappend x3dMsg $msg}
    }

  } emsg]} {
    errorMsg "ERROR adding 'cylinder' supplemental geometry: $emsg"
  }
}

# -------------------------------------------------------------------------------
# holes counter and spotface
proc x3dHoles {maxxyz} {
  global dim entCount holeDefinitions x3dFile viz syntaxErr DTR
  global objDesign

  set drillPoint [trimNum [expr {$maxxyz*0.02}]]
  set head 1
  set holeDEF {}

  set scale 1.
  if {$dim(unit) == "INCH"} {set scale 25.4}

  ::tcom::foreach e0 [$objDesign FindObjects [string trim item_identified_representation_usage]] {
    if {[catch {
      set e1 [[[$e0 Attributes] Item [expr 3]] Value]
      set e2 [[[$e0 Attributes] Item [expr 5]] Value]
      if {[string first "occurrence" [$e1 Type]] != -1 && [$e2 Type] == "mapped_item"} {
        set defID   [[[[$e1 Attributes] Item [expr 5]] Value] P21ID]
        set defType [[[[$e1 Attributes] Item [expr 5]] Value] Type]

        set holeName [split $defType "_"]
        foreach idx {0 1} {
          if {[string first "counter" [lindex $holeName $idx]] != -1 || [string first "spotface" [lindex $holeName $idx]] != -1} {set holeName [lindex $holeName $idx]}
        }

# check if there is an a2p3d associated with a hole occurrence
        set e3 [[[$e2 Attributes] Item [expr 3]] Value]
        if {[$e3 Type] == "axis2_placement_3d"} {
          if {$head} {
            outputMsg " Processing hole geometry" green
            puts $x3dFile "\n<!-- HOLES -->\n<Switch whichChoice='0' id='swHole'><Group>"
            set head 0
            set viz(HOL) 1
          }
          if {[lsearch $holeDEF $defID] == -1} {puts $x3dFile "<!-- $defType $defID -->"}

# hole geometry
          if {[info exists holeDefinitions($defID)]} {

# hole origin and axis transform
            set a2p3d [x3dGetA2P3D $e3]
            set origin [lindex $a2p3d 0]
            set axis   [lindex $a2p3d 1]
            set refdir [lindex $a2p3d 2]
            set transform [x3dTransform $origin $axis $refdir $holeName]

# drilled hole dimensions
            set drill [lindex $holeDefinitions($defID) 0]
            set drillRad [trimNum [expr {[lindex $drill 1]*0.5*$scale}] 5]
            set drillPoint $drillRad
            catch {unset drillDep}
            if {[llength $drill] > 2} {set drillDep [expr {[lindex $drill 2]*$scale}]}

# through hole
            set holeTop "true"
            set thruHole [lindex $holeDefinitions($defID) end-1]
            if {$thruHole == 1} {set holeTop "false"}

# hole name
            set holeName [lindex $holeDefinitions($defID) end]

            catch {unset sink}
            catch {unset bore}

            if {[llength $holeDefinitions($defID)] > 1} {
              set holeType [lindex [lindex $holeDefinitions($defID) 1] 0]

# countersink hole (cylinder, cone)
              if {$holeType == "countersink"} {
                set sink [lindex $holeDefinitions($defID) 1]

# compute length of countersink from angle and radius
                set sinkRad [trimNum [expr {[lindex $sink 1]*0.5*$scale}] 5]
                set sinkAng [expr {[lindex $sink 2]*0.5}]
                set sinkDep [expr {($sinkRad-$drillRad)/tan($sinkAng*$DTR)}]

# check for bad radius and depth
                if {$sinkRad <= $drillRad} {
                  set msg "Syntax Error: $holeType diameter <= drill diameter"
                  errorMsg $msg
                  foreach ent [list $holeType\_hole_definition simplified_$holeType\_hole_definition] {
                    if {[info exists entCount($ent)]} {
                      lappend syntaxErr($ent) [list $defID "countersink_diameter" $msg]
                      lappend syntaxErr($ent) [list $defID "drilled_hole_diameter" $msg]
                    }
                  }
                }
                if {[info exist drillDep]} {
                  if {$sinkDep >= $drillDep} {
                    set msg "Syntax Error: $holeType computed 'depth' >= drill depth"
                    errorMsg $msg
                    foreach ent [list $holeType\_hole_definition simplified_$holeType\_hole_definition] {
                      if {[info exists entCount($ent)]} {lappend syntaxErr($ent) [list $defID "drilled_hole_depth" $msg]}
                    }
                  }
                }

                if {[lsearch $holeDEF $defID] == -1} {
                  puts $x3dFile "$transform<Group DEF='$holeName$defID'>"
                  if {[info exists drillDep]} {
                    puts $x3dFile " <Transform rotation='1 0 0 1.5708' translation='0 0 [trimNum [expr {($drillDep+$sinkDep)*0.5}] 5]'>"
                    puts $x3dFile "  <Shape><Cylinder radius='$drillRad' height='[trimNum [expr {$drillDep-$sinkDep}] 5]' top='$holeTop' bottom='false' solid='false'></Cylinder><Appearance><Material diffuseColor='0 1 1'></Material></Appearance></Shape></Transform>"
                  }
                  puts $x3dFile " <Transform rotation='1 0 0 1.5708' translation='0 0 [trimNum [expr {$sinkDep*0.5}] 5]'>"
                  puts $x3dFile "  <Shape><Cone bottomRadius='$sinkRad' topRadius='$drillRad' height='[trimNum $sinkDep 5]' top='false' bottom='false' solid='false'></Cone><Appearance><Material diffuseColor='0 1 1'></Material></Appearance></Shape></Transform>"
                  puts $x3dFile "</Group></Transform>"
                  lappend holeDEF $defID
                } else {
                  puts $x3dFile "$transform<Group USE='$holeName$defID'></Group></Transform>"
                }

# counterbore or spotface hole (2 cylinders, flat cone)
              } elseif {$holeType == "counterbore" || $holeType == "spotface"} {
                set bore [lindex $holeDefinitions($defID) 1]
                set boreRad [expr {[lindex $bore 1]*0.5*$scale}]
                set boreDep [expr {[lindex $bore 2]*$scale}]

# check for bad radius and depth
                if {$boreRad <= $drillRad} {
                  set msg "Syntax Error: $holeType diameter <= drill diameter"
                  errorMsg $msg
                  foreach ent [list $holeType\_hole_definition simplified_$holeType\_hole_definition] {
                    if {[info exists entCount($ent)]} {
                      lappend syntaxErr($ent) [list $defID "counterbore" $msg]
                      lappend syntaxErr($ent) [list $defID "drilled_hole_diameter" $msg]
                    }
                  }
                }
                if {[info exist drillDep]} {
                  if {$boreDep >= $drillDep} {
                    set msg "Syntax Error: $holeType depth >= drill depth"
                    errorMsg $msg
                    foreach ent [list $holeType\_hole_definition simplified_$holeType\_hole_definition] {
                      if {[info exists entCount($ent)]} {
                        lappend syntaxErr($ent) [list $defID "counterbore" $msg]
                        lappend syntaxErr($ent) [list $defID "drilled_hole_depth" $msg]
                      }
                    }
                  }
                }

                if {[lsearch $holeDEF $defID] == -1} {
                  puts $x3dFile "$transform<Group DEF='$holeName$defID'>"
                  if {[info exists drillDep]} {
                    puts $x3dFile " <Transform rotation='1 0 0 1.5708' translation='0 0 [trimNum [expr {($drillDep+$boreDep)*0.5}] 5]'>"
                    puts $x3dFile "  <Shape><Cylinder radius='$drillRad' height='[trimNum [expr {$drillDep-$boreDep}] 5]' top='$holeTop' bottom='false' solid='false'></Cylinder><Appearance><Material diffuseColor='0 1 0'></Material></Appearance></Shape></Transform>"
                  }
                  puts $x3dFile " <Transform rotation='1 0 0 1.5708' translation='0 0 [trimNum $boreDep 5]'>"
                  puts $x3dFile "  <Shape><Cone bottomRadius='$boreRad' topRadius='$drillRad' height='0.001' top='false' bottom='false' solid='false'></Cone><Appearance><Material diffuseColor='0 1 0'></Material></Appearance></Shape></Transform>"
                  puts $x3dFile " <Transform rotation='1 0 0 1.5708' translation='0 0 [trimNum [expr {$boreDep*0.5}] 5]'>"
                  puts $x3dFile "  <Shape><Cylinder radius='$boreRad' height='[trimNum $boreDep 5]' top='false' bottom='false' solid='false'></Cylinder><Appearance><Material diffuseColor='0 1 0'></Material></Appearance></Shape></Transform>"
                  puts $x3dFile "</Group></Transform>"
                  lappend holeDEF $defID
                } else {
                  puts $x3dFile "$transform<Group USE='$holeName$defID'></Group></Transform>"
                }
              }
            }
          } else {
            errorMsg "Only drill entry points for holes are shown when no spreadsheet\n is generated with the report for Semantic PMI (See Options tab)."
            if {[lsearch $holeDEF $defID] == -1} {lappend holeDEF $defID}
          }

# point at origin of hole
          set e4 [[[$e3 Attributes] Item [expr 2]] Value]
          if {![info exists thruHole]} {set thruHole 0}
          x3dSuppGeomPoint $e4 $drillPoint $thruHole $holeName
        }
      }
    } emsg]} {
      errorMsg "ERROR adding 'hole' geometry: $emsg"
    }
  }
  if {$viz(HOL)} {puts $x3dFile "</Group></Switch>\n"}
  catch {unset holeDefinitions}
}

# -------------------------------------------------------------------------------
# set predefined color
proc x3dPreDefinedColor {name} {
  global defaultColor recPracNames spaces

  switch -- $name {
    black   {set color "0 0 0"}
    white   {set color "1 1 1"}
    red     {set color "1 0 0"}
    yellow  {set color "1 1 0"}
    green   {set color "0 1 0"}
    cyan    {set color "0 1 1"}
    blue    {set color "0 0 1"}
    magenta {set color "1 0 1"}
    default {
      set color [lindex $defaultColor 0]
      errorMsg "Syntax Error: draughting_pre_defined_colour name '$name' is not supported (using [lindex $defaultColor 1])$spaces\($recPracNames(model), Sec. 4.2.3, Table 2)"
    }
  }
  return $color
}

# -------------------------------------------------------------------------------
# get color name for b-rep part geometry
proc x3dColorName {color} {
  set savcolor $color
  set newcolor {}
  set lcolor [split $color " "]

# normalize color
  if {[catch {
    set newcolor [vectrim [vecnorm $color]]
  } emsg]} {
    return $color
  }

  set notnorm 1
  set ok 1
  foreach c $newcolor {if {$c != 0. && $c != 1.} {set ok 0}}
  if {$ok} {
    regsub -all {\.} [join $newcolor " "] "" newcolor
    if {$newcolor != "0 0 0" && $newcolor != "1 1 1"} {set color $newcolor; set notnorm 0}
  }

# threshhold color
  if {$notnorm} {
    set newcolor {}
    foreach val $lcolor {
      if {$val >= 0.66} {
        lappend newcolor 1
      } elseif {$val < 0.31} {
        lappend newcolor 0
      } else {
        lappend newcolor $val
      }
    }
    set newcolor [join $newcolor " "]
    if {$newcolor != "0 0 0" && $newcolor != "1 1 1"} {set color $newcolor}
  }

  set name ""
  switch -- $color {
    "0 0 0" {set name Black}
    "1 1 1" {set name White}
    "1 0 0" {set name Red}
    "1 1 0" {set name Yellow}
    "0 1 0" {set name Green}
    "0 1 1" {set name Cyan}
    "0 0 1" {set name Blue}
    "1 0 1" {set name Magenta}
  }

# approximate colors
  if {$name == ""} {
    if {[lindex $lcolor 0] == [lindex $lcolor 1] && [lindex $lcolor 0] == [lindex $lcolor 2]} {
      set name Gray
    } else {
      set diff(0) [expr {abs([lindex $lcolor 0]-[lindex $lcolor 1])}]
      set diff(1) [expr {abs([lindex $lcolor 0]-[lindex $lcolor 2])}]
      set diff(2) [expr {abs([lindex $lcolor 1]-[lindex $lcolor 2])}]
      set ok 1
      foreach i {0 1 2} {if {$diff($i) > 0.1} {set ok 0}}
      if {$ok} {set name Gray}
    }
  }
  return $name
}

# -------------------------------------------------------------------------------
# write geometry for polyline annotations
proc x3dPolylinePMI {} {
  global ao gpmiPlacement opt placeAnchor placeOrigin recPracNames savedViewFile savedViewName savedViewNames savedViewNone spaces
  global x3dColor x3dColorFile x3dColorsUsed x3dCoord x3dFile x3dIndex x3dIndexType x3dShape

  if {[catch {
    if {[info exists x3dCoord] || $x3dShape} {

# multiple saved views, write to individual files, collected in x3dViewpoint below
      set nosv 1
      set flist $x3dFile
      if {[llength $savedViewName] > 0} {
        set flist {}
        foreach svn $savedViewName {
          set svn1 "View[lsearch $savedViewNames $svn]"
          if {[info exists savedViewFile($svn1)]} {lappend flist $savedViewFile($svn1)}
        }
        set nosv 0
      }

# PMI not in a saved view
      if {$nosv} {
        incr savedViewNone
        if {$savedViewNone == 1} {puts $x3dFile "\n<!-- PMI not in a saved view -->\n<Switch whichChoice='0' id='swPMI'><Group>"}
      }

# loop over list of files from above
      foreach f $flist {

# multiple saved view color
        if {$opt(gpmiColor) == 3 && [llength $savedViewNames] > 1} {
          if {![info exists x3dColorFile($f)]} {set x3dColorFile($f) [x3dSetColor $opt(gpmiColor) 1]}
          set x3dColor $x3dColorFile($f)
        }

        if {[string length $x3dCoord] > 0} {

# placeholder transform
          if {[string first "placeholder" $ao] != -1} {
            set transform [x3dTransform $gpmiPlacement(origin) $gpmiPlacement(axis) $gpmiPlacement(refdir) "annotation placeholder"]
            puts $f $transform
          }

# start shape
          if {$x3dColor != ""} {
            puts $f "<Shape><Appearance><Material diffuseColor='$x3dColor' emissiveColor='$x3dColor'></Material></Appearance>"
            lappend x3dColorsUsed $x3dColor

          } else {
            puts $f "<Shape><Appearance><Material diffuseColor='0 0 0' emissiveColor='0 0 0'></Material></Appearance>"
            errorMsg "Syntax Error: Missing PMI Presentation color for [formatComplexEnt $ao] (using black)$spaces\($recPracNames(pmi242), Sec. 8.4, Figure 75)"
          }

# index and coordinates
          puts $f " <IndexedLineSet coordIndex='[string trim $x3dIndex]'>\n  <Coordinate point='[string trim $x3dCoord]'></Coordinate></IndexedLineSet></Shape>"

# end placeholder transform, add leader line
          if {[string first "placeholder" $ao] != -1} {
            puts $f "</Transform>"
            puts $f "<Shape><Appearance><Material emissiveColor='$x3dColor'></Material></Appearance>"
            puts $f " <IndexedLineSet coordIndex='0 1 -1'>\n  <Coordinate point='$placeOrigin $placeAnchor'></Coordinate></IndexedLineSet></Shape>"
          }

# end shape
        } elseif {$x3dShape} {
          puts $f "</Indexed$x3dIndexType\Set></Shape>"
        }
      }
      set x3dCoord ""
      set x3dIndex ""
      set x3dColor ""
      set x3dShape 0
    }
  } emsg3]} {
    errorMsg "ERROR writing polyline annotation graphics: $emsg3"
  }
  update idletasks
}

# -------------------------------------------------------------------------------
# write coordinate axes
proc x3dCoordAxes {size} {
  global x3dAxes x3dFile

# axes
  if {$x3dAxes} {
    puts $x3dFile "\n<!-- COORDINATE AXIS -->\n<Switch whichChoice='0' id='swAxes'><Group>"
    puts $x3dFile "<Shape id='x_axis'><Appearance><Material emissiveColor='1 0 0'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0 0 0 $size 0 0'></Coordinate></IndexedLineSet></Shape>"
    puts $x3dFile "<Shape id='y_axis'><Appearance><Material emissiveColor='0 .5 0'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0 0 0 0 $size 0'></Coordinate></IndexedLineSet></Shape>"
    puts $x3dFile "<Shape id='z_axis'><Appearance><Material emissiveColor='0 0 1'></Material></Appearance><IndexedLineSet coordIndex='0 1 -1'><Coordinate point='0 0 0 0 0 $size'></Coordinate></IndexedLineSet></Shape>"

# xyz labels
    set tsize [trimNum [expr {$size*0.33}]]
    puts $x3dFile "<Transform translation='$size 0 0' scale='$tsize $tsize $tsize'><Billboard axisOfRotation='0 0 0'><Shape><Appearance><Material diffuseColor='1 0 0'></Material></Appearance><Text string='\"X\"'><FontStyle family='\"SANS\"'></FontStyle></Text></Shape></Billboard></Transform>"
    puts $x3dFile "<Transform translation='0 $size 0' scale='$tsize $tsize $tsize'><Billboard axisOfRotation='0 0 0'><Shape><Appearance><Material diffuseColor='0 .5 0'></Material></Appearance><Text string='\"Y\"'><FontStyle family='\"SANS\"'></FontStyle></Text></Shape></Billboard></Transform>"
    puts $x3dFile "<Transform translation='0 0 $size' scale='$tsize $tsize $tsize'><Billboard axisOfRotation='0 0 0'><Shape><Appearance><Material diffuseColor='0 0 1'></Material></Appearance><Text string='\"Z\"'><FontStyle family='\"SANS\"'></FontStyle></Text></Shape></Billboard></Transform>"
    set tsize1 [trimNum [expr {$tsize*0.05}] 3]
    puts $x3dFile "<Transform scale='$tsize1 $tsize1 $tsize1'><Billboard axisOfRotation='0 0 0'><Shape><Text string='\"Visualization generated by the\",\"NIST STEP File Analyzer and Viewer\"'><FontStyle family='\"SANS\"'></FontStyle></Text><Appearance><Material diffuseColor='0 0 0'></Material></Appearance></Shape></Billboard></Transform>"
    puts $x3dFile "</Group></Switch>"
    set x3dAxes 0
  }
}

# -------------------------------------------------------------------------------
# get A2P3D origin, axis, refdir
proc x3dGetA2P3D {e0} {

  set origin "0 0 0"
  set axis   "0 0 1"
  set refdir "1 0 0"
  set debug 0

# a2p3d origin
  set a2 [[$e0 Attributes] Item [expr 2]]
  set e2 [$a2 Value]
  if {$e2 != ""} {
    set origin [vectrim [[[$e2 Attributes] Item [expr 2]] Value]]
    if {$debug} {errorMsg "      [$e2 Type] [$e2 P21ID] ([$a2 Name]) $origin" red}
  }

# a2p3d axis
  set a3 [[$e0 Attributes] Item [expr 3]]
  set e3 [$a3 Value]
  if {$e3 != ""} {
    set axis [[[$e3 Attributes] Item [expr 2]] Value]
    if {$debug} {errorMsg "      [$e3 Type] [$e3 P21ID] ([$a3 Name]) $axis" red}
  }

# a2p3d reference direction
  set a4 [[$e0 Attributes] Item [expr 4]]
  set e4 [$a4 Value]
  if {$e4 != ""} {
    set refdir [[[$e4 Attributes] Item [expr 2]] Value]
    if {$debug} {errorMsg "      [$e4 Type] [$e4 P21ID] ([$a4 Name]) $refdir" red}
  }

  return [list $origin $axis $refdir]
}

# -------------------------------------------------------------------------------
# generate transform
proc x3dTransform {origin axis refdir {text ""} {scale ""}} {

  set transform "<Transform"
  if {$origin != "0. 0. 0."} {append transform " translation='$origin'"}
  set rot [x3dGetRotation $axis $refdir $text]
  if {[lindex $rot 3] != 0} {append transform " rotation='$rot'"}
  if {$scale != ""} {append transform " scale='$scale'"}
  append transform ">"
  return $transform
}

# -------------------------------------------------------------------------------
# set x3d color
proc x3dSetColor {type {mode 0}} {
  global idxColor x3dColorBrepAdjusted

# black
  if {$type == 1} {return "0 0 0"}

# random
  if {$type == 2 || $type == 3} {
    incr idxColor($mode)
    switch -- $idxColor($mode) {
      1 {set color "1 0 0"}
      2 {set color "0 0 1"}
      3 {set color "0 .5 0"}
      4 {set color "1 0 1"}
      5 {set color "0 .5 .5"}
      6 {set color ".5 .25 0"}
      7 {set color "0 0 0"}
      8 {set color "1 1 0"}
      9 {set color "1 1 1"}
    }
    if {$idxColor($mode) == 9} {set idxColor($mode) 0}
  }

# change color if is it the same as brep color
  if {[info exists x3dColorBrepAdjusted]} {
    set color1 $color
    if {$color1 == "0 .5 0"}  {set color1 "0 1 0"}
    if {$color1 == "0 .5 .5"} {set color1 "0 1 1"}
    if {$color1 == $x3dColorBrepAdjusted} {set color [x3dSetColor $type $mode]}
  }
  return $color
}

# -------------------------------------------------------------------------------------------------
# open X3DOM file
proc openX3DOM {{fn ""} {numFile 0}} {
  global lastX3DOM multiFile opt scriptName x3dFileName viz

# f3 is for opening last x3dom file with function key F3
  set f3 1
  if {$fn == ""} {
    set f3 0
    set ok 0

# check that there is a file to view
    if {[info exists x3dFileName]} {if {[file exists $x3dFileName]} {set ok 1}}
    if {$ok} {
      set fn $x3dFileName

# no file, show message
    } elseif {$opt(VIZPMI) || $opt(VIZTPG) || $opt(VIZFEA) || $opt(VIZBRP)} {
      if {$opt(XLSCSV) == "None"} {errorMsg "There is nothing in the STEP file to view based on the View selections (Options tab)."}
      return
    }
  }
  if {[file exists $fn] != 1} {return}
  if {![info exists multiFile]} {set multiFile 0}

  set open 0
  if {![info exists viz(BRP)]} {set viz(BRP) 0}
  if {$f3} {
    set open 1
  } elseif {($viz(PMI) || $viz(TPG) || $viz(FEA) || $viz(BRP)) && $fn != "" && $multiFile == 0} {
    if {$opt(XL_OPEN)} {set open 1}
  }

# open file (.html) in web browser
  set lastX3DOM $fn
  if {$open} {
    outputMsg "\nOpening View in the default Web Browser: [file tail $fn] ([expr {[file size $fn]/1024}] Kb)" green
    catch {.tnb select .tnb.status}
    if {[catch {
      exec {*}[auto_execok start] "" [file nativename $fn]
    } emsg]} {
      if {[string first "UNC" $emsg] != -1} {set emsg [fixErrorMsg $emsg]}
      if {$emsg != ""} {
        errorMsg "ERROR opening View file: $emsg\n Open [truncFileName [file nativename $fn]]\n in a web browser that supports x3dom https://www.x3dom.org"
      }
    }
    update idletasks
  } elseif {$numFile == 0 && [string first "STEP-File-Analyzer.exe" $scriptName] != -1} {
    outputMsg " Use F3 to open the View (see Options tab)" red
  }
}

# -------------------------------------------------------------------------------
# get saved view names
proc getSavedViewName {objEntity} {
  global draughtingModels draftModelCameraNames draftModelCameras savedsavedViewNames savedViewName

# saved view name already saved
  if {[info exists savedsavedViewNames([$objEntity P21ID])]} {return $savedsavedViewNames([$objEntity P21ID])}

  set savedViewName {}
  foreach dm $draughtingModels {
    set entDraughtingModels [$objEntity GetUsedIn [string trim $dm] [string trim items]]
    set entDraughtingCallouts [$objEntity GetUsedIn [string trim draughting_callout] [string trim contents]]
    ::tcom::foreach entDraughtingCallout $entDraughtingCallouts {
      set entDraughtingModels [$entDraughtingCallout GetUsedIn [string trim $dm] [string trim items]]
    }

    ::tcom::foreach entDraughtingModel $entDraughtingModels {
      if {[info exists draftModelCameras([$entDraughtingModel P21ID])]} {
        set dmcn $draftModelCameraNames([$entDraughtingModel P21ID])
        if {[lsearch $savedViewName $dmcn] == -1} {lappend savedViewName $dmcn}
      }
    }
  }

# save saved view name
  if {![info exists savedsavedViewNames([$objEntity P21ID])]} {set savedsavedViewNames([$objEntity P21ID]) $savedViewName}
  return $savedViewName
}

# -------------------------------------------------------------------------------
# script for switch node
proc x3dSwitchScript {name {name1 ""}} {
  global savedViewNames x3dFile

  if {$name1 == ""} {set name1 $name}
  set viewName ""
  if {[string first "View" $name] == 0} {
    set viewName " [lindex $savedViewNames [string range $name end end]]"
    if {$name1 != ""} {set name1 "View[lsearch $savedViewNames $name1]"}
  }

  puts $x3dFile "\n<!-- $name$viewName switch -->\n<script>function tog$name\(choice){"
  puts $x3dFile " if (!document.getElementById('sw$name').checked) {document.getElementById('sw$name1').setAttribute('whichChoice', -1);} else {document.getElementById('sw$name1').setAttribute('whichChoice', 0);}"
  puts $x3dFile " document.getElementById('sw$name').checked = !document.getElementById('sw$name').checked;\n}</script>"
}

# -------------------------------------------------------------------------------
# generate x3d rotation (axis angle format) from axis2_placement_3d
proc x3dGetRotation {axis refdir {type ""}} {
  global x3dMsg

# check if one of the vectors is zero length, i.e., '0 0 0'
  set msg ""
  if {[veclen $axis] == 0 || [veclen $refdir] == 0} {
    set msg "Syntax Error: The orientation axis or ref_direction vector is '0 0 0'"
    if {$type != ""} {append msg " for a $type"}
    append msg "."

# check if axis and refdir are congruent
  } elseif {[veclen [veccross $axis $refdir]] == 0} {
    set msg "Syntax Error: The orientation axis and ref_direction vectors are congruent"
    if {$type != ""} {append msg " for a $type"}
    append msg "."
  }

  if {$msg != ""} {
    errorMsg $msg
    set msg1 [string range $msg 14 end]
    if {[lsearch $x3dMsg $msg1] == -1 && ([string first "supplemental" $msg1] != -1 || [string first "datum target" $msg1] != -1)} {lappend x3dMsg $msg1}
  }

# construct rotation matrix u, must normalize to use with quaternion
  set u3 [vecnorm $axis]
  set u1 [vecnorm [vecsub $refdir [vecmult $u3 [vecdot $refdir $u3]]]]
  set u2 [vecnorm [veccross $u3 $u1]]

# extract quaternion
  if {[lindex $u1 0] >= 0.0} {
    set tmp [expr {[lindex $u2 1] + [lindex $u3 2]}]
    if {$tmp >=  0.0} {
      set q(0) [expr {[lindex $u1 0] + $tmp + 1.}]
      set q(1) [expr {[lindex $u3 1] - [lindex $u2 2]}]
      set q(2) [expr {[lindex $u1 2] - [lindex $u3 0]}]
      set q(3) [expr {[lindex $u2 0] - [lindex $u1 1]}]
    } else {
      set q(0) [expr {[lindex $u3 1] - [lindex $u2 2]}]
      set q(1) [expr {[lindex $u1 0] - $tmp + 1.}]
      set q(2) [expr {[lindex $u2 0] + [lindex $u1 1]}]
      set q(3) [expr {[lindex $u1 2] + [lindex $u3 0]}]
    }
  } else {
    set tmp [expr {[lindex $u2 1] - [lindex $u3 2]}]
    if {$tmp >= 0.0} {
      set q(0) [expr {[lindex $u1 2] - [lindex $u3 0]}]
      set q(1) [expr {[lindex $u2 0] + [lindex $u1 1]}]
      set q(2) [expr {1. - [lindex $u1 0] + $tmp}]
      set q(3) [expr {[lindex $u3 1] + [lindex $u2 2]}]
    } else {
      set q(0) [expr {[lindex $u2 0] - [lindex $u1 1]}]
      set q(1) [expr {[lindex $u1 2] + [lindex $u3 0]}]
      set q(2) [expr {[lindex $u3 1] + [lindex $u2 2]}]
      set q(3) [expr {1. - [lindex $u1 0] - $tmp}]
    }
  }

# normalize quaternion
  set lenq [expr {sqrt($q(0)*$q(0) + $q(1)*$q(1) + $q(2)*$q(2) + $q(3)*$q(3))}]
  if {$lenq != 0.} {
    foreach i {0 1 2 3} {set q($i) [expr {$q($i) / $lenq}]}
  } else {
    foreach i {0 1 2 3} {set q($i) 0.}
  }

# convert from quaterion to x3d rotation
  set rotation_changed {0 1 0 0}
  set angle [expr {acos($q(0))*2.0}]
  if {$angle != 0.} {
    set sina [expr {sin($angle*0.5)}]
    set axm 0.
    foreach i {0 1 2} {
      set i1 [expr {$i+1}]
      set ax [expr {-$q($i1) / $sina}]
      lset rotation_changed $i $ax
      set axa [expr {abs($ax)}]
      if {$axa > $axm} {set axm $axa}
    }
    if {$axm > 0. && $axm < 1.} {
      foreach i {0 1 2} {lset rotation_changed $i [expr {[lindex $rotation_changed $i]/$axm}]}
    }
    lset rotation_changed 3 $angle
    foreach i {0 1 2 3} {lset rotation_changed $i [trimNum [lindex $rotation_changed $i] 4]}
  }
  return $rotation_changed
}
